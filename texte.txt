<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Atomes Clicker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --fg:#ffffff;
      --bg:#0b0b0f;
      --card:rgba(255,255,255,.10);
      --pill:rgba(255,255,255,.18);
      --accent:rgba(255,255,255,.85);
      --grid-max:clamp(760px,88vw,1200px);
    }
    /* Thèmes */
    body.theme-dark{ --fg:#f5f7ff; --bg:#0b0b0f; --card:rgba(255,255,255,.10); --pill:rgba(255,255,255,.18); --accent:rgba(255,255,255,.85); }
    body.theme-light{ --fg:#0b0b0f; --bg:#f6f8ff; --card:rgba(0,0,0,.06); --pill:rgba(0,0,0,.12); --accent:rgba(12,16,32,.85); }
    body.theme-rainbow{ --fg:#ffffff; --accent:rgba(255,255,255,.85); }
    html, body {
      margin:0; padding:0; width:100%; height:100%; min-height:100dvh;
      font-family:'Orbitron',sans-serif; color:var(--fg);
      overflow-x:hidden; overflow-y:auto; user-select:none;
    }
    body { background: var(--bg); transition: background .4s ease, color .4s ease; min-height:100dvh; display:flex; flex-direction:column; }
    /* Arc-en-ciel animé uniquement pour le thème rainbow */
    body.theme-rainbow{ background: linear-gradient(270deg, red, orange, yellow, green, blue, indigo, violet); background-size:1400% 1400%; animation: rainbow 20s linear infinite; }
    @keyframes rainbow { 0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%} }

    .page { display:none; width:100%; height:100%; box-sizing:border-box; position:relative; padding:clamp(1.2rem, 5vh, 3rem) clamp(1rem, 3.5vw, 3rem); overflow:auto; }
    .page.active { display:flex; flex-direction:column; align-items:center; gap:clamp(1rem, 2.6vh, 2rem); justify-content:flex-start; flex:1; }

    /* Boutons navigation / barre du haut */
    .app-header {
      position:sticky;
      top:0;
      z-index:150;
      background:var(--bg);
      box-shadow:0 6px 18px rgba(0,0,0,.22);
      backdrop-filter:blur(12px);
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .nav-menu {
      display:flex;
      align-items:center;
      justify-content:center;
      gap:clamp(.35rem, .8vw, .7rem);
      padding:clamp(.45rem, 1.3vh, .75rem) clamp(1rem, 3vw, 2rem);
      margin:0 auto;
      width:100%;
      list-style:none;
      flex-wrap:nowrap;
      overflow-x:auto;
      scrollbar-width:none;
      -webkit-overflow-scrolling:touch;
    }
    .nav-menu::-webkit-scrollbar { display:none; }
    .nav-button {
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
      min-height:clamp(2rem, 5vh, 2.6rem);
      padding:clamp(.35rem, 1vh, .6rem) clamp(.75rem, 1.8vw, 1.2rem);
      border:none;
      border-radius:999px;
      background:var(--pill);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.58rem, .95vw, .78rem);
      font-weight:600;
      letter-spacing:.12em;
      text-transform:uppercase;
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
      white-space:nowrap;
    }
    .nav-button[disabled]{
      opacity:.4;
      cursor:not-allowed;
      pointer-events:none;
    }
    .nav-button .nav-label {
      line-height:1;
    }
    .nav-button:hover,
    .nav-button:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.26);
    }
    .nav-button.active {
      background:var(--accent);
      color:var(--bg);
      box-shadow:0 12px 24px rgba(0,0,0,.28);
    }
    main {
      flex:1;
      display:flex;
      flex-direction:column;
    }
    #pageContainer {
      flex:1;
      display:flex;
      flex-direction:column;
      position:relative;
    }
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    .placeholder-card {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      background:var(--card);
      border-radius:18px;
      padding:clamp(1.2rem, 3vh, 2rem) clamp(1.2rem, 4vw, 2.2rem);
      box-shadow:0 14px 28px rgba(0,0,0,.28);
      display:flex;
      flex-direction:column;
      gap:.75rem;
    }

    .revive-wrap{
      width:min(100%, var(--grid-max));
      margin:0 auto;
    }
    .revive-card{
      display:flex;
      flex-direction:column;
      gap:clamp(.85rem, 2vh, 1.2rem);
    }
    .revive-heading{
      margin:0;
      font-size:clamp(1.2rem, 2.6vw, 1.8rem);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    .revive-intro{
      margin:0;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
      opacity:.8;
    }
    .revive-stats{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(180px, 1fr));
      gap:clamp(.6rem, 1.8vh, 1rem);
    }
    .revive-stat{
      background:var(--card);
      border-radius:14px;
      padding:clamp(.6rem, 1.6vh, .9rem) clamp(.9rem, 2vw, 1.2rem);
      display:flex;
      flex-direction:column;
      gap:.35rem;
    }
    .revive-stat span{
      text-transform:uppercase;
      letter-spacing:.14em;
      font-size:clamp(.65rem, .9vw, .8rem);
      opacity:.65;
    }
    .revive-stat strong{
      font-size:clamp(1rem, 1.8vw, 1.4rem);
    }
    .revive-offer{
      display:flex;
      flex-wrap:wrap;
      gap:clamp(.8rem, 2vh, 1.2rem);
      justify-content:space-between;
      align-items:center;
      padding:clamp(.9rem, 2vh, 1.3rem);
      border-radius:14px;
      background:var(--pill);
    }
    .revive-offer-details{
      display:flex;
      flex-direction:column;
      gap:.45rem;
    }
    .revive-offer-line{
      display:flex;
      justify-content:space-between;
      gap:1.2rem;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
    }
    .revive-offer-line span{
      text-transform:uppercase;
      letter-spacing:.12em;
      opacity:.7;
    }
    .revive-offer button{
      padding:clamp(.6rem, 1.8vh, 1rem) clamp(1.2rem, 3vw, 2rem);
      border:none;
      border-radius:999px;
      background:linear-gradient(135deg, rgba(120,220,255,.4), rgba(60,120,255,.75));
      color:#fff;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.85rem, 1.3vw, 1.1rem);
      letter-spacing:.14em;
      text-transform:uppercase;
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, opacity .2s ease;
      white-space:nowrap;
    }
    .revive-offer button:disabled{
      opacity:.5;
      cursor:not-allowed;
      box-shadow:none;
    }
    .revive-offer button:not(:disabled):hover{
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,.28);
    }
    .revive-locked{
      margin:0;
      font-size:clamp(.8rem, 1.2vw, .95rem);
      opacity:.75;
      text-align:center;
    }
    .revive-note{
      margin:0;
      font-size:clamp(.78rem, 1.15vw, .95rem);
      opacity:.75;
    }
    .placeholder-card h2 {
      margin:0;
      font-size:clamp(1.1rem, 2.4vw, 1.6rem);
      letter-spacing:.08em;
    }
    .placeholder-card p {
      margin:0;
      font-size:clamp(.85rem, 1.3vw, 1.05rem);
      opacity:.8;
    }

    .infos-wrapper {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:clamp(1rem, 2.6vh, 1.8rem);
    }
    .info-breakdown-grid,
    .info-bubble-grid {
      display:grid;
      width:100%;
      gap:clamp(.75rem, 2.2vh, 1.2rem);
    }
    .info-breakdown-grid {
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
    }
    .info-bubble-grid {
      grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
    }
    .info-card {
      background:var(--card);
      border-radius:18px;
      padding:clamp(.85rem, 2vh, 1.35rem) clamp(1rem, 2.4vw, 1.8rem);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
      display:flex;
      flex-direction:column;
      gap:clamp(.55rem, 1.6vh, .95rem);
    }
    .info-card h2 {
      margin:0;
      font-size:clamp(.82rem, 1.25vw, 1rem);
      letter-spacing:.18em;
      text-transform:uppercase;
      opacity:.82;
    }
    .info-card--compact {
      gap:clamp(.45rem, 1.4vh, .8rem);
    }
    .info-metrics {
      display:flex;
      flex-direction:column;
      gap:clamp(.45rem, 1.4vh, .75rem);
    }
    .info-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:clamp(.6rem, 1.6vw, 1rem);
      font-size:clamp(.75rem, 1.05vw, .9rem);
      flex-wrap:wrap;
    }
    .info-card--compact .info-row {
      background:var(--pill);
      border-radius:14px;
      padding:clamp(.4rem, 1.2vh, .65rem) clamp(.65rem, 2vw, .95rem);
      box-shadow:0 8px 18px rgba(0,0,0,.16);
    }
    .info-card--breakdown .info-row {
      padding:0;
      background:transparent;
      box-shadow:none;
    }
    .info-row span {
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.72;
      flex:1 1 auto;
    }
    .info-row strong {
      font-size:clamp(.92rem, 1.5vw, 1.25rem);
      font-weight:700;
      letter-spacing:.08em;
      margin-left:auto;
      text-align:right;
    }
    .info-row.total {
      border-top:1px solid rgba(255,255,255,.12);
      padding-top:clamp(.45rem, 1.2vh, .7rem);
      margin-top:clamp(.45rem, 1.2vh, .7rem);
    }
    .info-card--compact .info-row.total {
      border-top:none;
      margin-top:0;
    }
    .info-row-multi {
      align-items:flex-start;
    }
    .info-row-multi span {
      padding-top:.2rem;
    }
    .multiplier-list {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      flex:1;
    }
    .multiplier-item {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.75rem;
      font-size:clamp(.72rem, 1.05vw, .88rem);
      background:var(--pill);
      border-radius:12px;
      padding:clamp(.4rem, 1.2vh, .6rem) clamp(.6rem, 1.8vw, .9rem);
      box-shadow:0 6px 16px rgba(0,0,0,.16);
    }
    .multiplier-item span {
      text-transform:uppercase;
      letter-spacing:.12em;
      opacity:.72;
    }
    .multiplier-item strong {
      font-size:clamp(.9rem, 1.4vw, 1.1rem);
      letter-spacing:.08em;
    }

    /* Sélecteur de thème (boutons shop) */
    .theme-selector {
      display:flex;
      align-items:center;
      gap:clamp(.55rem, 1.5vw, 1rem);
      background:var(--pill);
      padding:clamp(.45rem, 1.3vh, .85rem) clamp(.65rem, 1.9vw, 1.3rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
    }
    .theme-label {
      font-size:clamp(.65rem,1vw,.9rem);
      text-transform:uppercase;
      letter-spacing:.18em;
      opacity:.75;
    }
    #themeControls {
      display:flex;
      align-items:center;
      gap:clamp(.4rem, 1vw, .7rem);
    }
    #themeControls button { width:clamp(2.4rem, 4vw, 3.3rem); height:clamp(2.4rem, 4vw, 3.3rem); border-radius:12px; border:none; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.22); transition:transform .2s ease, box-shadow .2s ease; }
    #themeControls button:hover { transform:translateY(-2px); box-shadow:0 10px 20px rgba(0,0,0,.28); }
    #themeControls button.active { box-shadow:0 0 0 4px var(--accent), 0 6px 16px rgba(0,0,0,.22); }
    #themeControls button[data-theme="light"] { background:#ffffff; }
    #themeControls button[data-theme="dark"] { background:#0b0b0f; }
    #themeControls button[data-theme="rainbow"] { background:linear-gradient(135deg, red, orange, yellow, green, cyan, blue, violet); }

    /* Compteurs */
    .atomsCluster {
      display:grid;
      grid-template-columns:minmax(0, 1fr) minmax(0, 1.8fr) minmax(0, 1fr);
      grid-template-areas:"apc atoms aps";
      gap:clamp(.35rem, 1.6vw, 1.2rem);
      width:100%;
      margin:clamp(.4rem, 2.4vh, 1.4rem) 0 0;
      align-self:stretch;
      align-items:stretch;
      justify-items:stretch;
    }
    .atomsCluster > * {
      min-width:0;
    }
    .atomsBox {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:.3rem;
      font-size:clamp(.85rem, 2.4vw, 2.2rem);
      padding:clamp(.5rem, 1.8vw, 1.3rem) clamp(.8rem, 2.8vw, 2.3rem);
      background:var(--card);
      border-radius:14px;
      box-shadow:0 8px 20px rgba(0,0,0,.2);
      width:100%;
      max-width:none;
      justify-self:stretch;
      box-sizing:border-box;
      grid-area:atoms;
    }
    .atomsLabel {
      font-size:clamp(.5rem, .95vw, .88rem);
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.78;
    }
    .atomsValue {
      font-weight:700;
      line-height:1.1;
      font-size:clamp(1.1rem, 4.5vw, 3.2rem);
    }
    .statPill {
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      background:var(--pill);
      padding:clamp(.4rem, 1.4vw, .95rem) clamp(.55rem, 1.8vw, 1.2rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
      gap:.2rem;
      min-height:100%;
      box-sizing:border-box;
    }
    .statLabel {
      font-size:clamp(.48rem,.95vw,.85rem);
      text-transform:uppercase;
      letter-spacing:.18em;
      opacity:.7;
    }
    .statValue {
      font-size:clamp(.65rem, 2.1vw, 1.45rem);
      font-weight:700;
      line-height:1.1;
    }
    .statPill-apc {
      background:linear-gradient(140deg, rgba(255,140,82,.25), rgba(255,200,160,.18));
      grid-area:apc;
    }
    .statPill-aps {
      background:linear-gradient(140deg, rgba(0,210,255,.25), rgba(120,255,220,.18));
      grid-area:aps;
    }

    /* Icône atome */
    .atom { width:clamp(9rem,22vmin,18rem); aspect-ratio:1; pointer-events:none; transition:transform .18s ease, filter .18s ease; transform-origin:center; }
    .atom.colorShift { filter:drop-shadow(0 0 18px rgba(255,213,79,.55)) drop-shadow(0 0 32px rgba(255,213,79,.35)); }
    .atom.enflé { transform:scale(1.22); }
    .atom.enflé.crit { transform:scale(1.32); }
    .atom.crit {
      filter:drop-shadow(0 0 20px rgba(255,255,210,.9)) drop-shadow(0 0 42px rgba(255,220,150,.8)) drop-shadow(0 0 70px rgba(255,190,120,.6));
      animation:critSpark .55s ease-out;
    }
    .nucleus { fill:var(--fg); transition:fill .2s ease, filter .2s ease; }
    .nucleus.colorShift { fill:#ffd54f; }
    .atom.crit .nucleus { fill:#ffffff; filter:drop-shadow(0 0 18px rgba(255,255,255,.85)); }
    .orbit { fill:none; stroke:var(--fg); stroke-width:2; opacity:.9; transition:stroke .2s ease, opacity .2s ease; }
    .atom.crit .orbit { stroke:rgba(255,244,214,.95); opacity:1; filter:drop-shadow(0 0 14px rgba(255,240,200,.65)); }
    @keyframes critSpark {
      0% { filter:drop-shadow(0 0 8px rgba(255,255,255,.8)) drop-shadow(0 0 18px rgba(255,220,150,.75)); }
      40% { filter:drop-shadow(0 0 26px rgba(255,255,200,1)) drop-shadow(0 0 52px rgba(255,200,140,.85)); }
      100% { filter:drop-shadow(0 0 14px rgba(255,240,210,.75)) drop-shadow(0 0 30px rgba(255,200,140,.65)); }
    }
    #confettiLayer {
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:998;
    }
    .confetti-piece {
      position:absolute;
      display:block;
      will-change:transform, opacity;
      opacity:0;
      filter:drop-shadow(0 0 6px rgba(0,0,0,.2));
    }

    .frenzyOrb {
      position:absolute;
      width:clamp(9rem, 22vmin, 18rem);
      aspect-ratio:1;
      border:none;
      padding:0;
      background:transparent center/contain no-repeat;
      box-shadow:0 10px 26px rgba(0,0,0,.28);
      pointer-events:none;
      opacity:0;
      transform:translate(-50%, -50%) scale(.7);
      transition:opacity .25s ease, transform .25s ease;
      z-index:200;
      cursor:pointer;
    }
    .frenzyOrb:focus-visible {
      outline:3px solid var(--accent);
      outline-offset:6px;
    }
    .frenzyOrb.visible {
      opacity:1;
      pointer-events:auto;
      transform:translate(-50%, -50%) scale(1);
    }
    .frenzyOrb:disabled {
      cursor:default;
    }
    #frenzyOrb {
      background-image:url("Assets/Image/frenesieAPC.png");
    }
    #apsFrenzyOrb {
      background-image:url("Assets/Image/frenesieAPS.png");
    }

    .frenzyStatus {
      font-size:clamp(.55rem, .95vw, .8rem);
      opacity:.8;
      margin-top:.2rem;
      letter-spacing:.05em;
    }
    .frenzyStatus:empty { display:none; }
    .frenzyStatus.active {
      opacity:1;
      color:var(--accent);
    }

    .auto-gacha-panel {
      position:fixed;
      left:50%;
      bottom:clamp(1rem, 3vh, 2.4rem);
      transform:translateX(-50%);
      background:var(--card);
      border-radius:14px;
      box-shadow:0 14px 26px rgba(0,0,0,.32);
      padding:clamp(.65rem, 1.5vh, 1rem) clamp(.9rem, 2vw, 1.4rem);
      display:flex;
      flex-direction:column;
      gap:.4rem;
      z-index:120;
      min-width:clamp(12rem, 42vw, 20rem);
      border:1px solid rgba(255,255,255,.16);
    }
    .auto-gacha-panel.hidden {
      display:none;
    }
    .auto-gacha-header {
      font-size:clamp(.75rem,1.2vw,.95rem);
      letter-spacing:.12em;
      text-transform:uppercase;
      opacity:.8;
    }
    .auto-gacha-content {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:clamp(.6rem, 1.8vw, 1.2rem);
    }
    .auto-gacha-name {
      font-size:clamp(.95rem, 1.8vw, 1.2rem);
      font-weight:700;
    }
    .auto-gacha-result {
      font-size:clamp(.95rem, 1.6vw, 1.15rem);
      text-align:right;
    }

    /* SHOP */
    .shop-wrap {
      width:100%;
      display:flex;
      justify-content:center;
    }
    .card {
      background: var(--card);
      border-radius:12px;
      box-sizing:border-box;
      padding:clamp(1rem, 2.5vh, 1.5rem);
      width:100%;
    }
    .shop-grid {
      width:min(100%, var(--grid-max));
      display:grid;
      gap:clamp(.9rem, 2vw, 1.6rem);
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
    }
    .shop-card {
      display:flex;
      flex-direction:column;
      gap:clamp(.75rem, 2vh, 1.2rem);
      padding:clamp(.9rem, 2.2vh, 1.4rem) clamp(1rem, 2.8vw, 1.8rem);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
    }
    .shop-card-title {
      margin:0;
      font-size:clamp(.95rem, 1.6vw, 1.25rem);
      text-transform:uppercase;
      letter-spacing:.12em;
    }
    .shop-upgrade {
      display:flex;
      flex-direction:column;
      gap:.45rem;
    }
    .shop-upgrade-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.6rem;
    }
    .shop-upgrade-label {
      font-size:clamp(.72rem, 1.1vw, .95rem);
      text-transform:uppercase;
      letter-spacing:.16em;
    }
    .shop-upgrade-meta {
      font-size:clamp(.6rem, .95vw, .8rem);
      opacity:.7;
    }
    .shop-options {
      display:flex;
      gap:clamp(.4rem, 1.2vw, .85rem);
      flex-wrap:wrap;
    }
    .shop-option {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      border:none;
      border-radius:12px;
      padding:clamp(.45rem, 1.1vw, .75rem) clamp(.6rem, 1.8vw, 1rem);
      min-width:clamp(3.8rem, 12vw, 5.1rem);
      background:var(--pill);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.6rem, .95vw, .82rem);
      font-weight:600;
      letter-spacing:.12em;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
      gap:.2rem;
    }
    .shop-option:hover,
    .shop-option:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.24);
    }
    .shop-option .option-tier {
      font-size:clamp(.8rem, 1.4vw, 1.05rem);
      font-weight:700;
    }
    .shop-option .option-price {
      font-size:clamp(.52rem, .85vw, .72rem);
      opacity:.8;
      line-height:1.1;
    }
    .shop-option.not-available {
      background:rgba(255,255,255,.12);
      color:rgba(255,255,255,.55);
      box-shadow:none;
    }
    body.theme-light .shop-option.not-available {
      background:rgba(0,0,0,.08);
      color:rgba(0,0,0,.5);
    }
    .shop-option:disabled {
      cursor:not-allowed;
      opacity:.75;
      transform:none;
    }
    .shop-upgrade-single .shop-option {
      width:100%;
      flex-direction:row;
      justify-content:space-between;
      align-items:center;
    }
    .shop-upgrade-single .option-tier {
      font-size:clamp(.85rem, 1.5vw, 1.1rem);
    }
    .shop-card.gacha-card .shop-options {
      justify-content:space-between;
    }

    /* OPTIONS */
    .options-wrap {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      display:grid;
      gap:clamp(.9rem, 2vw, 1.6rem);
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
    }
    .options-card {
      display:flex;
      flex-direction:column;
      gap:clamp(.6rem, 2vh, 1rem);
      box-shadow:0 8px 20px rgba(0,0,0,.18);
    }
    .options-title {
      margin:0;
      font-size:clamp(1rem, 2vw, 1.35rem);
      text-transform:uppercase;
      letter-spacing:.14em;
    }
    .options-text {
      margin:0;
      font-size:clamp(.75rem, 1.1vw, .95rem);
      opacity:.8;
    }
    .options-reset {
      align-self:flex-start;
      padding:clamp(.55rem, 1.4vw, .9rem) clamp(1rem, 2.4vw, 1.6rem);
      border:none;
      border-radius:10px;
      background:linear-gradient(135deg, rgba(255,90,90,.35), rgba(190,0,0,.55));
      color:#fff;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.75rem, 1vw, .95rem);
      letter-spacing:.14em;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:0 8px 20px rgba(0,0,0,.22);
      transition:transform .2s ease, box-shadow .2s ease, filter .2s ease;
    }
    .options-reset:hover,
    .options-reset:focus-visible {
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,.28);
      filter:brightness(1.05);
    }

    /* Loot encart */
    .loot {
      margin-top:clamp(.6rem, 2vh, 1rem);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:clamp(.6rem, 2vw, 1.2rem);
      flex-wrap:wrap;
      background:var(--pill);
      padding:clamp(.55rem,1.2vw,.95rem) clamp(.75rem,2vw,1.3rem);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,.18);
    }
    .loot.hidden { display:none; }
    .loot-detail { display:flex; flex-direction:column; gap:.2rem; }
    .loot-name { font-size:clamp(.9rem,1.4vw,1.1rem); font-weight:700; }
    .loot-family { font-size:clamp(.7rem,1.1vw,.9rem); opacity:.75; }
    .loot-result {
      display:inline-block;
      position:relative;
      overflow:hidden;
      font-size:clamp(.95rem,1.6vw,1.2rem);
      font-weight:700;
      margin-left:auto;
      text-align:right;
    }
    .loot-result.is-new {
      color:#ffffff;
      text-shadow:0 0 12px rgba(255,255,255,.85), 0 0 24px rgba(160,220,255,.75);
    }
    .loot-result.is-new::after {
      content:"";
      position:absolute;
      top:0; bottom:0; left:-70%; right:-70%;
      background:linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.9) 45%, rgba(255,255,255,0) 60%);
      transform:skewX(-15deg);
      animation:lootShine 1.8s ease-in-out infinite;
      opacity:.7;
    }
    .loot-result.rarity-common { color:#34d058; }
    .loot-result.rarity-uncommon { color:#1a8f52; }
    .loot-result.rarity-rare { color:#4ea1ff; }
    .loot-result.rarity-epic { color:#bb7bff; }
    .loot-result.rarity-legendary { color:#ffa54b; }
    .loot-result.rarity-mythic {
      background:linear-gradient(90deg, red, orange, yellow, green, cyan, blue, violet, red);
      background-size:300% 100%;
      -webkit-background-clip:text;
      color:transparent;
      animation:lootRainbow 3s linear infinite;
      text-shadow:0 0 18px rgba(255,255,255,.35);
    }
    @keyframes lootRainbow {
      0% { background-position:0% 50%; }
      100% { background-position:100% 50%; }
    }
    @keyframes lootShine {
      0% { transform:translateX(-80%) skewX(-15deg); }
      100% { transform:translateX(120%) skewX(-15deg); }
    }

    /* GACHA PAGE */
    .gacha-wrap { width:min(100%,var(--grid-max,1200px)); margin:0 auto; box-sizing:border-box; display:flex; flex-direction:column; gap:clamp(1rem,3vh,2rem); align-items:center; justify-content:flex-start; flex:1; }

    .gacha-info {
      background:var(--card); border-radius:12px; padding:clamp(.6rem,1.5vh,.95rem);
      display:flex; flex-direction:column; gap:clamp(.45rem,1.1vh,.8rem);
      align-items:stretch; align-self:stretch;
      min-height:clamp(48px,3.4vw,56px); box-shadow:0 12px 24px rgba(0,0,0,.18);
      grid-column:3 / 13; grid-row:1 / 4;
      width:100%; height:100%; box-sizing:border-box;
    }
    .gacha-info .info-title {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:.75rem;
      background:var(--pill); border-radius:12px; padding:.35rem .85rem;
      font-size:clamp(.72rem,1vw,.9rem);
    }
    .gacha-info .info-title .iso-count {
      font-size:clamp(.68rem,.95vw,.85rem);
      opacity:.85;
    }
    .gacha-info .info-lines {
      display:flex;
      flex-direction:column;
      width:100%;
      gap:clamp(.35rem,1vw,.6rem);
    }
    .gacha-info .info-line {
      background:var(--pill); border-radius:999px; padding:.28rem .7rem;
      font-size:clamp(.66rem,.9vw,.85rem); opacity:.95; text-align:left;
    }
    .awaken-box {
      display:contents;
    }
    .awaken-card {
      background:var(--card);
      border-radius:12px;
      padding:clamp(.45rem,1.2vh,.75rem);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(.4rem,1vh,.65rem);
      box-shadow:0 12px 24px rgba(0,0,0,.18);
      width:100%;
      box-sizing:border-box;
      height:100%;
    }
    .awaken-card-single {
      grid-column:1 / 4;
      grid-row:8 / 10;
      align-self:stretch;
      justify-self:stretch;
    }
    .awaken-card-all {
      grid-column:13 / 18;
      grid-row:1 / 2;
      min-height:clamp(48px,3.4vw,56px);
    }
    .awaken-card .awaken-btn {
      width:100%;
      max-width:clamp(11rem, 26vw, 18rem);
      margin:0 auto;
      text-align:center;
    }
    @media (max-width: 900px) {
      .awaken-card-single,
      .awaken-card-all {
        grid-column:1 / -1;
        grid-row:auto;
      }
    }
    .awaken-btn {
      padding:clamp(.45rem,1.1vh,.7rem) clamp(.7rem,1.6vw,1rem);
      border:none;
      border-radius:12px;
      background:linear-gradient(135deg, rgba(0,255,255,.35), rgba(0,160,255,.55));
      color:var(--fg);
      font-size:clamp(.72rem,1.05vw,.9rem);
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
      transition:transform .15s ease, box-shadow .2s ease, filter .2s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:.35rem;
    }
    .awaken-btn:hover:not(:disabled) {
      transform:translateY(-1px);
      box-shadow:0 10px 22px rgba(0,0,0,.3);
    }
    .awaken-btn:disabled {
      cursor:not-allowed;
      opacity:.55;
      filter:grayscale(.2);
      box-shadow:none;
    }

    .awaken-all-btn {
      background:linear-gradient(135deg, rgba(255,196,99,.55), rgba(255,120,0,.7));
      box-shadow:0 6px 18px rgba(0,0,0,.22);
    }

    .awaken-discount-counter {
      grid-column:1 / -1;
      justify-self:end;
      align-self:end;
      font-size:clamp(.52rem, min(.9vw, 1.2vh), .7rem);
      opacity:.55;
      color:var(--fg);
      pointer-events:none;
      text-align:right;
      padding:clamp(.15rem, .4vh, .3rem) clamp(.18rem, .5vw, .35rem) 0;
    }

    .awaken-discount-counter.has-discount {
      opacity:.75;
    }

    .gacha-grid {
      --cell-size: clamp(36px, min(4vw, 6vh), 60px);
      margin:0 auto;
      width:min(100%,var(--grid-max,1100px));
      max-width:var(--grid-max,1100px);
      display:grid;
      grid-template-columns: repeat(18, minmax(0, 1fr));
      grid-auto-rows:var(--cell-size);
      gap:clamp(.08rem, min(.35vw, .8vh), .25rem);
      position:relative;
    }
    .cell {
      background:var(--bg-base, var(--card)); border:1px solid rgba(255,255,255,.12); border-radius:10px;
      padding:clamp(.2rem, min(.45vw, .8vh), .32rem) clamp(.18rem, min(.42vw, .75vh), .3rem);
      text-align:center; cursor:pointer;
      display:flex; flex-direction:column; align-items:center; justify-content:center; transition:background .3s ease, transform .2s ease, border-color .3s ease;
      color:#0b0b0f; min-height:var(--cell-size);
      position:relative; overflow:hidden;
    }
    .cell:hover { transform:translateY(-2px); }
    @keyframes awakenSpin {
      from { transform:rotate(0deg); }
      to { transform:rotate(360deg); }
    }
    .cell.awaken-ready {
      box-shadow:0 0 18px rgba(255,255,255,.45), 0 0 32px rgba(0,200,255,.25);
    }
    .cell.awaken-ready::after {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:inherit;
      background:conic-gradient(from 0deg, rgba(255,255,255,.05) 0deg, rgba(0,255,255,.55) 120deg, rgba(255,255,255,.05) 240deg, rgba(0,255,120,.55) 360deg);
      animation:awakenSpin 2.4s linear infinite;
      pointer-events:none;
      -webkit-mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #000 calc(100% - 2px));
      mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #000 calc(100% - 2px));
      opacity:.85;
    }
    .cell .Z { font-size:clamp(.5rem, min(.95vw, 1.8vh), .75rem); opacity:.75; }
    .cell .sym { font-size:clamp(.75rem, min(1.35vw, 2.7vh), 1.1rem); font-weight:700; }
    .cell.owned { background:var(--bg-owned, var(--card)); border-color:rgba(255,255,255,.28); }
    body.theme-light .cell { border-color:rgba(0,0,0,.08); }
    body.theme-light .cell.owned { border-color:rgba(0,0,0,.18); }

    .hidden { display:none; }

    /* Layout spécifiques par page */
    #mainPage.page.active { justify-content:flex-start; }
    #mainPage .atomsCluster { order:1; margin-bottom:clamp(1.2rem, 4vh, 3rem); }
    #mainPage .atom { order:2; margin:0 auto; }

    #shopPage { padding-left:clamp(1rem, 3vw, 2.2rem); padding-right:clamp(1rem, 3vw, 2.2rem); }
    #shopPage .atomsCluster { order:1; }
    #shopPage .shop-wrap { order:2; margin:clamp(.6rem, 2vh, 1.2rem) auto; }

    #gachaPage.page.active { justify-content:flex-start; }
    #gachaPage .gacha-wrap {
      order:2;
      flex:1;
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:clamp(.6rem, min(2vh, 2vw), 1.4rem);
      padding-top:clamp(1rem, 4vh, 2.5rem);
    }

    .loot-detail { flex:1; }

    /* MOLECULES PAGE */
    .molecules-wrap {
      width:min(100%, var(--grid-max));
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:clamp(.8rem, 2.6vh, 1.4rem);
    }
    .molecule-header {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:clamp(.6rem, 2vw, 1rem);
      background:var(--card);
      border-radius:18px;
      padding:clamp(.7rem, 1.8vh, 1.1rem) clamp(.9rem, 2.4vw, 1.4rem);
      box-shadow:0 10px 26px rgba(0,0,0,.22);
    }
    .molecule-resource {
      display:flex;
      flex-direction:column;
      gap:.2rem;
      min-width:140px;
    }
    .molecule-resource span {
      font-size:clamp(.58rem, .95vw, .75rem);
      letter-spacing:.16em;
      text-transform:uppercase;
      opacity:.68;
    }
    .molecule-resource strong {
      font-size:clamp(.95rem, 1.6vw, 1.3rem);
      letter-spacing:.05em;
    }
    .molecule-result {
      border-radius:14px;
      padding:clamp(.55rem, 1.4vh, .85rem) clamp(.75rem, 2vw, 1.2rem);
      font-size:clamp(.68rem, 1vw, .88rem);
      text-align:center;
      box-shadow:0 8px 20px rgba(0,0,0,.18);
    }
    .molecule-result.success {
      background:rgba(80, 220, 170, .18);
      border:1px solid rgba(120, 255, 210, .45);
    }
    .molecule-result.fail {
      background:rgba(255, 120, 120, .16);
      border:1px solid rgba(255, 150, 150, .4);
    }
    .molecule-result.hidden { display:none; }
    .molecule-notice {
      background:var(--card);
      border-radius:16px;
      padding:clamp(.7rem, 1.8vh, 1.1rem) clamp(.9rem, 2.4vw, 1.4rem);
      box-shadow:0 8px 18px rgba(0,0,0,.18);
      font-size:clamp(.7rem, 1vw, .92rem);
      text-align:center;
    }
    .molecule-tier {
      background:var(--card);
      border-radius:20px;
      padding:clamp(.75rem, 2vh, 1.2rem) clamp(.9rem, 2.6vw, 1.6rem);
      display:flex;
      flex-direction:column;
      gap:clamp(.6rem, 1.8vh, 1rem);
      box-shadow:0 12px 28px rgba(0,0,0,.22);
    }
    .molecule-tier-list {
      display:flex;
      flex-direction:column;
      gap:clamp(.75rem, 2vh, 1.2rem);
    }
    .molecule-tier-header {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:.6rem;
    }
    .molecule-tier-title {
      margin:0;
      font-size:clamp(.85rem, 1.2vw, 1.15rem);
      letter-spacing:.14em;
      text-transform:uppercase;
    }
    .molecule-tier-meta {
      display:flex;
      flex-wrap:wrap;
      gap:clamp(.45rem, 1.5vw, .9rem);
      font-size:clamp(.6rem, .9vw, .78rem);
      opacity:.78;
    }
    .molecule-card {
      background:rgba(0,0,0,.12);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      padding:clamp(.65rem, 1.6vh, .95rem) clamp(.75rem, 2.1vw, 1.2rem);
      display:flex;
      flex-direction:column;
      gap:.55rem;
      transition:transform .2s ease, box-shadow .2s ease;
    }
    .molecule-card--colored {
      border-color:var(--molecule-color);
      box-shadow:0 10px 24px rgba(0,0,0,.18), 0 0 12px var(--molecule-color, rgba(255,255,255,.18));
    }
    .molecule-card--unlocked {
      background:rgba(120,255,210,.12);
      border-color:rgba(120,255,210,.4);
      box-shadow:0 12px 26px rgba(0,0,0,.22), 0 0 0 1px rgba(120,255,210,.4);
    }
    .molecule-card:hover { transform:translateY(-2px); }
    .molecule-card-header {
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:.65rem;
    }
    .molecule-formula {
      font-size:clamp(.95rem, 1.4vw, 1.3rem);
      font-weight:700;
      letter-spacing:.08em;
    }
    .molecule-status {
      font-size:clamp(.58rem, .95vw, .75rem);
      letter-spacing:.12em;
      text-transform:uppercase;
      opacity:.75;
      white-space:nowrap;
    }
    .molecule-summary {
      margin:0;
      font-size:clamp(.68rem, .95vw, .85rem);
      line-height:1.4;
      opacity:.88;
    }
    .molecule-meta {
      display:flex;
      flex-wrap:wrap;
      gap:clamp(.4rem, 1.4vw, .8rem);
      font-size:clamp(.6rem, .9vw, .78rem);
      opacity:.75;
    }
    .molecule-actions {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:.6rem;
    }
    .molecule-action {
      border:none;
      border-radius:999px;
      padding:clamp(.38rem, .9vh, .55rem) clamp(.85rem, 2.2vw, 1.25rem);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.6rem, .95vw, .8rem);
      letter-spacing:.12em;
      text-transform:uppercase;
      font-weight:600;
      background:var(--accent);
      color:var(--bg);
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, filter .2s ease;
      box-shadow:0 8px 18px rgba(0,0,0,.22);
    }
    .molecule-action:hover:not(:disabled),
    .molecule-action:focus-visible:not(:disabled) {
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,.28);
      filter:brightness(1.05);
    }
    .molecule-action:disabled {
      cursor:not-allowed;
      opacity:.45;
      box-shadow:none;
      transform:none;
    }
    .molecule-note {
      font-size:clamp(.6rem, .9vw, .78rem);
      opacity:.7;
    }
    .molecule-reqs {
      margin:0;
      padding-left:1.2rem;
      display:flex;
      flex-direction:column;
      gap:.2rem;
      font-size:clamp(.58rem, .85vw, .75rem);
      opacity:.7;
    }
    .molecule-reqs li { list-style:disc; }

    .info-empty {
      margin:0;
      font-size:clamp(.72rem, 1.05vw, .88rem);
      opacity:.7;
    }
    .bonus-lines {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:clamp(.45rem, 1.3vh, .75rem);
    }
    .bonus-lines li {
      background:var(--pill);
      border-radius:14px;
      padding:clamp(.45rem, 1.3vh, .75rem) clamp(.7rem, 2vw, 1.1rem);
      box-shadow:0 8px 18px rgba(0,0,0,.16);
      line-height:1.4;
      font-size:clamp(.7rem, 1.05vw, .9rem);
    }
    .trophy-list {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:clamp(.5rem,1.3vh,.8rem);
    }
    .trophy-list li {
      background:var(--pill);
      border-radius:12px;
      padding:clamp(.45rem,1.2vh,.75rem) clamp(.6rem,1.6vw,1.1rem);
      display:flex;
      flex-direction:column;
      gap:.3rem;
      border:1px solid transparent;
      box-shadow:0 8px 18px rgba(0,0,0,.16);
    }
    .trophy-list li.trophy-unlocked {
      border-color:rgba(255,255,255,.35);
      box-shadow:0 12px 28px rgba(0,0,0,.25);
    }
    .trophy-list li.trophy-locked {
      opacity:.9;
    }
    .trophy-name {
      font-weight:700;
      font-size:clamp(.85rem,1.4vw,1.05rem);
    }
    .trophy-desc {
      font-size:clamp(.68rem,1vw,.85rem);
      opacity:.82;
    }
    .trophy-progress {
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:clamp(.6rem,.9vw,.75rem);
      opacity:.78;
      gap:.5rem;
    }
    .trophy-progress-value {
      font-weight:600;
    }
    .trophy-progress-target {
      opacity:.75;
      text-align:right;
    }
    .set-status-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
      gap:clamp(.45rem, 1.4vh, .85rem);
    }
    .set-status-card {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:clamp(.45rem, 1.2vw, .85rem);
      padding:clamp(.55rem, 1.4vh, .9rem) clamp(.75rem, 2vw, 1.1rem);
      border-radius:12px;
      background:var(--pill);
      box-shadow:0 6px 16px rgba(0,0,0,.14);
    }
    .set-status-card.set-complete {
      box-shadow:0 0 0 2px rgba(120,255,200,.35), 0 6px 16px rgba(0,0,0,.16);
    }
    .set-status-name {
      font-weight:600;
      letter-spacing:.05em;
    }
    .set-status-info {
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:.2rem;
      font-size:clamp(.7rem, 1.3vw, .95rem);
    }
    .set-status-progress {
      opacity:.75;
    }
    .set-status-state {
      font-weight:700;
    }
    .set-status-card.set-complete .set-status-state {
      color:var(--accent);
    }
    .set-status-card.set-incomplete .set-status-state {
      opacity:.7;
    }

    @media (max-width: 900px) {
      .page { padding:clamp(1.25rem,5vh,2.5rem) clamp(1rem,5vw,2rem); }
      .nav-menu { justify-content:flex-start; }
      .nav-button { flex:0 0 auto; }
      .theme-selector {
        width:100%;
        flex-direction:column;
        align-items:flex-start;
        gap:clamp(.45rem,2vh,.9rem);
      }
      #themeControls {
        width:100%;
        justify-content:flex-start;
        flex-wrap:wrap;
        gap:clamp(.45rem,3vw,.85rem);
      }
      #themeControls button { width:clamp(2.4rem,10vw,3rem); height:clamp(2.4rem,10vw,3rem); }
      .atomsCluster {
        grid-template-columns:minmax(0, 1fr) minmax(0, 1.5fr) minmax(0, 1fr);
        gap:clamp(.3rem, 2.4vw, .9rem);
      }
      .atomsBox {
        font-size:clamp(.7rem, 4.6vw, 1.9rem);
        padding:clamp(.45rem, 3vw, 1rem) clamp(.6rem, 5vw, 1.6rem);
      }
      .statPill {
        padding:clamp(.35rem, 2.6vw, .85rem) clamp(.45rem, 4vw, 1.1rem);
      }
      .statLabel { letter-spacing:.12em; }
      .statValue { font-size:clamp(.6rem,4.8vw,1.4rem); }
      #shopPage { padding-left:clamp(.75rem,4vw,1.4rem); padding-right:clamp(.75rem,4vw,1.4rem); }
      .shop-grid { grid-template-columns:1fr; }
      .shop-card { gap:clamp(.6rem, 2vh, 1rem); }
      .shop-options { justify-content:flex-start; }
      .shop-option { min-width:clamp(3.4rem, 28vw, 4.8rem); }
      .gacha-wrap { gap:clamp(1rem,4vh,1.8rem); }
      .gacha-grid { width:100%; max-width:100%; }
    }

    @media (max-width: 720px) {
      .nav-menu { justify-content:flex-start; }
      .nav-button { min-width:clamp(4.2rem, 26vw, 6rem); }
      .gacha-info .info-lines { grid-template-columns:1fr; }
    }

    @media (max-height: 720px) {
      .atom { width:clamp(7.5rem,20vmin,15rem); }
      .gacha-grid { --cell-size: clamp(32px, min(3.6vw, 5.5vh), 48px); }
      .gacha-info { min-height:clamp(32px, min(3.6vw, 5.5vh), 48px); }
    }

    .modal-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,.6);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; padding:1.5rem;
    }


    .modal-overlay.hidden {
      display:none;
    }


    .modal-content {
      background:var(--card); color:var(--fg); border-radius:16px;
      padding:clamp(1rem,2.5vh,1.6rem) clamp(1.2rem,3vw,2rem);
      width:min(100%,520px); box-shadow:0 18px 36px rgba(0,0,0,.28);
      display:flex; flex-direction:column; gap:clamp(.75rem,2vh,1.2rem);
    }

    .reset-description { margin:0; font-size:clamp(.85rem,1.2vw,1rem); opacity:.85; }
    .reset-word {
      font-size:clamp(1rem,2.2vw,1.4rem);
      font-weight:700;
      letter-spacing:.08em;
      text-transform:uppercase;
      text-align:center;
      padding:.65rem 1rem;
      border-radius:12px;
      background:var(--pill);
    }
    #resetInput {
      padding:.65rem .85rem;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.2);
      color:var(--fg);
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.85rem,1.2vw,1rem);
      outline:none;
    }
    body.theme-light #resetInput {
      background:rgba(255,255,255,.65);
      border-color:rgba(0,0,0,.15);
      color:#0b0b0f;
    }
    .reset-actions { display:flex; justify-content:flex-end; gap:.75rem; }
    .reset-actions button {
      padding:.6rem 1.1rem;
      border:none;
      border-radius:10px;
      font-family:'Orbitron',sans-serif;
      font-size:clamp(.8rem,1.15vw,.95rem);
      cursor:pointer;
      background:var(--pill);
      color:var(--fg);
    }
    .reset-actions button.confirm {
      background:linear-gradient(135deg, rgba(255,90,90,.45), rgba(190,0,0,.65));
      color:#fff;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .reset-actions button.confirm:disabled {
      opacity:.6;
      cursor:not-allowed;
      box-shadow:none;
    }

    .modal-header { display:flex; justify-content:space-between; align-items:center; gap:1rem; }

    .modal-header h2 { margin:0; font-size:clamp(1.1rem,2.4vw,1.6rem); }

    .modal-close {
      background:transparent; border:none; color:var(--fg); font-size:1.6rem; cursor:pointer; line-height:1;
    }

  </style>
</head>
<body class="theme-rainbow">
  <div id="confettiLayer" aria-hidden="true"></div>
  <header class="app-header" role="banner">
    <nav class="nav-menu" aria-label="Navigation principale">
      <button class="nav-button active" type="button" data-page-target="mainPage">
        <span class="nav-label">Atoms</span>
      </button>
      <button class="nav-button" type="button" data-page-target="shopPage">
        <span class="nav-label">Shop</span>
      </button>
      <button class="nav-button" type="button" data-page-target="gachaPage">
        <span class="nav-label">Table</span>
      </button>
      <button class="nav-button" type="button" data-page-target="moleculesPage">
        <span class="nav-label">Molécules</span>
      </button>
      <button class="nav-button" type="button" data-page-target="infosPage">
        <span class="nav-label">Infos</span>
      </button>
      <button class="nav-button" type="button" data-page-target="revivePage">
        <span class="nav-label">Revive</span>
      </button>
      <button class="nav-button" type="button" data-page-target="optionsPage">
        <span class="nav-label">Options</span>
      </button>
    </nav>
  </header>
  <main id="pageContainer">
    <!-- PAGE PRINCIPALE -->
    <section id="mainPage" class="page active" aria-labelledby="mainTitle">
      <h1 id="mainTitle" class="sr-only">ATOMS</h1>

      <div class="atomsCluster">
        <div class="atomsBox">
          <span class="atomsLabel">Atoms</span>
          <strong class="atomsValue" id="atoms">0.0</strong>
        </div>
        <div class="statPill statPill-apc">
          <span class="statLabel">APC</span>
          <span class="statValue" id="apc">1.0</span>
          <span class="frenzyStatus" id="apcFrenzyStatus" aria-live="polite"></span>
        </div>
        <div class="statPill statPill-aps">
          <span class="statLabel">APS</span>
          <span class="statValue" id="aps">0.0</span>
          <span class="frenzyStatus" id="apsFrenzyStatus" aria-live="polite"></span>
        </div>
      </div>

      <img class="atom" id="atomIcon" src="Assets/Image/Atom.png" alt="Icône d'atome" />

      <button id="frenzyOrb" class="frenzyOrb" type="button" aria-label="Activer la Frénésie APC" disabled></button>
      <button id="apsFrenzyOrb" class="frenzyOrb" type="button" aria-label="Activer la Frénésie APS" disabled></button>

      <div id="autoGachaPanel" class="auto-gacha-panel hidden" aria-live="polite">
        <div id="autoGachaHeader" class="auto-gacha-header" aria-label="Prochain tirage gratuit">—</div>
        <div class="auto-gacha-content">
          <span id="autoGachaName" class="auto-gacha-name">—</span>
          <span id="autoGachaResult" class="loot-result auto-gacha-result" data-base-class="loot-result auto-gacha-result">—</span>
        </div>
      </div>
    </section>

    <!-- PAGE SHOP -->
    <section id="shopPage" class="page" aria-labelledby="shopTitle">
      <h1 id="shopTitle" class="sr-only">Shop</h1>
      <div class="atomsCluster">
        <div class="atomsBox">
          <span class="atomsLabel">Atoms</span>
          <strong class="atomsValue" id="atomsShop">0.0</strong>
        </div>
        <div class="statPill statPill-apc">
          <span class="statLabel">APC</span>
          <span class="statValue" id="apcShop">1.0</span>
        </div>
        <div class="statPill statPill-aps">
          <span class="statLabel">APS</span>
          <span class="statValue" id="apsShop">0.0</span>
        </div>
      </div>
      <div class="shop-wrap">
        <div class="shop-grid">
          <div class="card shop-card">
            <h2 class="shop-card-title">Production</h2>
            <div class="shop-upgrade">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">APC</span>
                <span id="apcInfo" class="shop-upgrade-meta">Niveau 0</span>
              </div>
              <div class="shop-options">
                <button id="buyApc" class="shop-option" type="button">
                  <span class="option-tier">x1</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyApc10" class="shop-option" type="button">
                  <span class="option-tier">x10</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyApc100" class="shop-option" type="button">
                  <span class="option-tier">x100</span>
                  <span class="option-price">—</span>
                </button>
              </div>
            </div>
            <div class="shop-upgrade">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">APS</span>
                <span id="autoInfo" class="shop-upgrade-meta">Niveau 0</span>
              </div>
              <div class="shop-options">
                <button id="buyAuto" class="shop-option" type="button">
                  <span class="option-tier">x1</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyAuto10" class="shop-option" type="button">
                  <span class="option-tier">x10</span>
                  <span class="option-price">—</span>
                </button>
                <button id="buyAuto100" class="shop-option" type="button">
                  <span class="option-tier">x100</span>
                  <span class="option-price">—</span>
                </button>
              </div>
            </div>
            <div class="shop-upgrade shop-upgrade-single">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">Multiplicateur APC</span>
                <span id="apcMultiInfo" class="shop-upgrade-meta">Achats 0</span>
              </div>
              <button id="buyApcMulti" class="shop-option" type="button">
                <span class="option-tier">×2</span>
                <span class="option-price">—</span>
              </button>
            </div>
            <div class="shop-upgrade shop-upgrade-single">
              <div class="shop-upgrade-header">
                <span class="shop-upgrade-label">Multiplicateur APS</span>
                <span id="apsMultiInfo" class="shop-upgrade-meta">Achats 0</span>
              </div>
              <button id="buyApsMulti" class="shop-option" type="button">
                <span class="option-tier">×2</span>
                <span class="option-price">—</span>
              </button>
            </div>
          </div>

          <div class="card shop-card gacha-card">
            <h2 class="shop-card-title">Tirages Gacha</h2>
            <div class="shop-options gacha-options">
              <button id="rollBtn" class="shop-option" type="button">
                <span class="option-tier">x1</span>
                <span class="option-price" id="rollCostOnBtn">100.0</span>
              </button>
              <button id="roll10Btn" class="shop-option" type="button">
                <span class="option-tier">x10</span>
                <span class="option-price" id="roll10Cost">—</span>
              </button>
              <button id="roll100Btn" class="shop-option" type="button">
                <span class="option-tier">x100</span>
                <span class="option-price" id="roll100Cost">—</span>
              </button>
            </div>
            <div class="loot hidden" id="lastLootBox">
              <div class="loot-detail">
                <span id="lastLootName" class="loot-name">—</span>
                <span id="lastLootFam" class="loot-family">—</span>
              </div>
              <span id="lastLootType" class="loot-result" data-base-class="loot-result">—</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- PAGE GACHA -->
    <section id="gachaPage" class="page" aria-labelledby="gachaTitle">
      <h1 id="gachaTitle" class="sr-only">Table</h1>
      <div class="gacha-wrap">
        <div id="periodicGrid" class="gacha-grid">
          <div id="gachaInfo" class="gacha-info">
            <div id="elementTitle" class="info-title">
              <span id="elementName">Clique un élément dans la grille</span>
              <span id="elementIsoCount" class="iso-count">—</span>
            </div>
            <div class="info-lines">
              <div class="info-line" id="elementFamily">Famille : —</div>
            </div>
          </div>
          <div id="awakenWrapper" class="awaken-box hidden">
            <div id="awakenSingleCard" class="awaken-card awaken-card-single hidden">
              <button id="awakenBtn" class="awaken-btn" type="button">Éveil</button>
            </div>
            <div id="awakenAllCard" class="awaken-card awaken-card-all hidden">
              <button id="awakenAllBtn" class="awaken-btn awaken-all-btn hidden" type="button">Éveiller tout</button>
            </div>
          </div>
          <div id="awakenDiscountCounter" class="awaken-discount-counter">Rabais éveil : 0</div>
        </div>
      </div>
    </section>

    <!-- PAGE MOLECULES -->
    <section id="moleculesPage" class="page" aria-labelledby="moleculesTitle">
      <h1 id="moleculesTitle" class="sr-only">Molécules</h1>
      <div class="molecules-wrap">
        <header class="molecule-header">
          <div class="molecule-resource">
            <span>Isotopes disponibles</span>
            <strong id="moleculeIsoStock">0</strong>
          </div>
          <div class="molecule-resource">
            <span>Poussière générée</span>
            <strong id="moleculeDust">0</strong>
          </div>
        </header>
        <div id="moleculeLastResult" class="molecule-result hidden" role="status" aria-live="polite"></div>
        <div id="moleculeUnlockNotice" class="molecule-notice hidden"></div>
        <div id="moleculeList" class="molecule-tier-list"></div>
      </div>
    </section>

    <!-- PAGE INFOS -->
    <section id="infosPage" class="page" aria-labelledby="infosTitle">
      <h1 id="infosTitle" class="sr-only">Infos</h1>
      <div class="infos-wrapper">
        <div class="info-breakdown-grid">
          <article class="info-card info-card--breakdown">
            <h2>Détails APC</h2>
            <div class="info-metrics">
              <div class="info-row"><span>Base</span><strong id="infosApcBase">0</strong></div>
              <div class="info-row"><span>Bonus plat</span><strong id="infosApcFlat">0</strong></div>
              <div class="info-row"><span>Après bonus</span><strong id="infosApcAfterFlat">0</strong></div>
              <div class="info-row info-row-multi">
                <span>Multiplicateurs</span>
                <ul class="multiplier-list" id="infosApcMultipliers"></ul>
              </div>
              <div class="info-row total"><span>Total APC</span><strong id="infosApcTotal">0</strong></div>
            </div>
          </article>
          <article class="info-card info-card--breakdown">
            <h2>Détails APS</h2>
            <div class="info-metrics">
              <div class="info-row"><span>Base</span><strong id="infosApsBase">0</strong></div>
              <div class="info-row"><span>Bonus plat</span><strong id="infosApsFlat">0</strong></div>
              <div class="info-row"><span>Après bonus</span><strong id="infosApsAfterFlat">0</strong></div>
              <div class="info-row info-row-multi">
                <span>Multiplicateurs</span>
                <ul class="multiplier-list" id="infosApsMultipliers"></ul>
              </div>
              <div class="info-row total"><span>Total APS</span><strong id="infosApsTotal">0</strong></div>
            </div>
          </article>
        </div>
        <div class="info-bubble-grid">
          <article class="info-card info-card--compact">
            <h2>Session en cours</h2>
            <div class="info-metrics">
              <div class="info-row"><span>Total d'Atoms gagnés</span><strong id="infosSessionAtoms">0</strong></div>
              <div class="info-row"><span>Clics manuels</span><strong id="infosSessionClicks">0</strong></div>
              <div class="info-row"><span>Durée en ligne</span><strong id="infosSessionDuration">00:00:00</strong></div>
            </div>
          </article>
          <article class="info-card info-card--compact">
            <h2>Progression globale</h2>
            <div class="info-metrics">
              <div class="info-row"><span>Atoms (revive en cours)</span><strong id="infosReviveAtoms">0</strong></div>
              <div class="info-row"><span>Total d'Atoms</span><strong id="infosLifetimeAtoms">0</strong></div>
              <div class="info-row"><span>Clics (revive en cours)</span><strong id="infosReviveClicks">0</strong></div>
              <div class="info-row"><span>Clics totaux</span><strong id="infosLifetimeClicks">0</strong></div>
              <div class="info-row"><span>Revives complétés</span><strong id="infosReviveCount">0</strong></div>
              <div class="info-row"><span>Temps depuis le début</span><strong id="infosTotalRuntime">0 h 0 min</strong></div>
            </div>
          </article>
          <article class="info-card info-card--compact">
            <h2>Trophées</h2>
            <p class="info-empty" id="infosTrophyEmpty">Aucun trophée débloqué pour le moment.</p>
            <ul class="trophy-list hidden" id="infosTrophyList"></ul>
          </article>
          <article class="info-card info-card--compact">
            <h2>Effets actifs</h2>
            <p class="info-empty" id="infosBonusEmpty">Aucun bonus actif pour le moment.</p>
            <ul class="bonus-lines hidden" id="infosBonusLines"></ul>
          </article>
          <article class="info-card info-card--compact">
            <h2>Bonus de set</h2>
            <p class="info-empty" id="infosSetEmpty">Découvre des éléments pour activer les bonus de set.</p>
            <div class="set-status-grid hidden" id="infosSetStatus"></div>
          </article>
          <article class="info-card info-card--compact">
            <h2>Molécules actives</h2>
            <p class="info-empty" id="infosMoleculeEmpty">Aucune molécule synthétisée pour le moment.</p>
            <ul class="bonus-lines hidden" id="infosMoleculeList"></ul>
          </article>
        </div>
      </div>
    </section>

    <!-- PAGE REVIVE -->
    <section id="revivePage" class="page" aria-labelledby="reviveTitle">
      <h1 id="reviveTitle" class="sr-only">Revive</h1>
      <div class="revive-wrap">
        <article class="card revive-card">
          <h2 class="revive-heading">Module de renaissance</h2>
          <p class="revive-intro">Sacrifie ta progression actuelle pour recommencer une partie avec des bases plus solides et des bonus permanents.</p>
          <div class="revive-stats">
            <div class="revive-stat"><span>Revives réalisés</span><strong id="reviveCountStat">0</strong></div>
            <div class="revive-stat"><span>Base de départ APC/APS</span><strong id="reviveBaseStat">+0</strong></div>
            <div class="revive-stat"><span>Bonus par achat</span><strong id="reviveShopStat">+1</strong></div>
          </div>
          <div id="reviveOffer" class="revive-offer">
            <div class="revive-offer-details">
              <div class="revive-offer-line"><span>Coût</span><strong id="reviveCostValue">1.000b</strong></div>
              <div class="revive-offer-line"><span>Récompense</span><strong id="reviveRewardValue">+200 APC / APS</strong></div>
            </div>
            <button id="reviveBuyBtn" type="button">Déclencher la renaissance</button>
          </div>
          <p class="revive-note">Chaque renaissance remet à zéro tes Atoms, isotopes, bonus et améliorations, mais offre un bonus permanent d'APC/APS affiché ci-dessus et augmente le gain par achat du shop.</p>
          <p id="reviveLockedMessage" class="revive-locked hidden">Accumule suffisamment d'Atoms pour débloquer cette renaissance.</p>
        </article>
      </div>
    </section>

    <!-- PAGE OPTIONS -->
    <section id="optionsPage" class="page" aria-labelledby="optionsTitle">
      <h1 id="optionsTitle" class="sr-only">Options</h1>
      <div class="options-wrap">
        <div class="card options-card">
          <h2 class="options-title">Thème</h2>
          <div class="theme-selector" role="group" aria-label="Gestion du thème">
            <span class="theme-label">Thème</span>
            <div id="themeControls" aria-label="Sélecteur de thème">
              <button type="button" data-theme="light" aria-label="Activer le thème clair" title="Thème clair"></button>
              <button type="button" data-theme="dark" aria-label="Activer le thème sombre" title="Thème sombre"></button>
              <button type="button" data-theme="rainbow" aria-label="Activer le thème arc-en-ciel" title="Thème arc-en-ciel"></button>
            </div>
          </div>
        </div>
        <div class="card options-card">
          <h2 class="options-title">Gestion</h2>
          <p class="options-text">Réinitialise complètement ta sauvegarde et remet le jeu à zéro.</p>
          <button id="resetBtn" class="danger options-reset" type="button">Réinitialiser la partie</button>
        </div>
      </div>
    </section>
  </main>

  <div id="resetModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="resetTitle">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="resetTitle">Confirmer la réinitialisation</h2>
        <button id="closeReset" class="modal-close" type="button" aria-label="Fermer la fenêtre">×</button>
      </div>
      <p class="reset-description">Pour remettre la partie à zéro, recopie le mot ci-dessous puis valide.</p>
      <div id="resetWord" class="reset-word">—</div>
      <label class="reset-description" for="resetInput">Recopiez le mot affiché</label>
      <input id="resetInput" type="text" autocomplete="off" spellcheck="false" />
      <div class="reset-actions">
        <button id="cancelReset" type="button">Annuler</button>
        <button id="confirmReset" class="confirm" type="button" disabled>Réinitialiser</button>
      </div>
    </div>
  </div>

  <script src="Assets/config/game-config.js"></script>
  <script>
    /* ===================== Données ===================== */

    const GAME_CONFIG = (typeof window !== "undefined" && window.ATOMES_CONFIG && typeof window.ATOMES_CONFIG === "object")
      ? window.ATOMES_CONFIG
      : {};

    function getConfigValue(path){
      if (!Array.isArray(path)) return undefined;
      let current = GAME_CONFIG;
      for (const key of path){
        if (!current || typeof current !== "object") return undefined;
        current = current[key];
      }
      return current;
    }

    function getNumberFromConfig(path, fallback, options = {}){
      const { min = -Infinity, max = Infinity, integer = false } = options;
      let safeFallback = Number(fallback);
      if (!Number.isFinite(safeFallback)) safeFallback = 0;
      if (integer) safeFallback = Math.floor(safeFallback);
      if (safeFallback < min) safeFallback = min;
      if (safeFallback > max) safeFallback = max;
      const rawValue = getConfigValue(path);
      if (rawValue === undefined) return safeFallback;
      const numericValue = typeof rawValue === "bigint" ? Number(rawValue) : Number(rawValue);
      if (!Number.isFinite(numericValue)) return safeFallback;
      let candidate = integer ? Math.floor(numericValue) : numericValue;
      if (candidate < min || candidate > max) return safeFallback;
      return candidate;
    }

    function isPlainObject(value){
      if (!value || typeof value !== "object") return false;
      const proto = Object.getPrototypeOf(value);
      return proto === Object.prototype || proto === null;
    }

    function getObjectFromConfig(path, fallback = {}){
      const raw = getConfigValue(path);
      return isPlainObject(raw) ? raw : fallback;
    }

    function getArrayFromConfig(path, fallback = []){
      const raw = getConfigValue(path);
      if (Array.isArray(raw)) return raw.slice();
      return Array.isArray(fallback) ? fallback.slice() : [];
    }

    function sanitizeNumber(value, fallback, options = {}){
      const { min = -Infinity, max = Infinity, integer = false } = options;
      let result = Number(value);
      if (!Number.isFinite(result)) result = fallback;
      if (!Number.isFinite(result)) result = 0;
      if (integer) result = Math.floor(result);
      if (result < min) result = min;
      if (result > max) result = max;
      return result;
    }

    function sanitizeString(value, fallback = ""){
      return typeof value === "string" ? value : fallback;
    }

    function sanitizeColors(raw, fallback = {}){
      const source = isPlainObject(raw) ? raw : {};
      const fb = isPlainObject(fallback) ? fallback : {};
      return {
        base: sanitizeString(source.base, fb.base || ""),
        owned: sanitizeString(source.owned, fb.owned || "")
      };
    }

    function sanitizeColorValue(value, fallback = ""){
      const str = sanitizeString(value, fallback);
      if (/^#[0-9a-fA-F]{3,8}$/.test(str)) return str;
      if (/^rgba?\(/i.test(str)) return str;
      if (/^hsla?\(/i.test(str)) return str;
      return fallback;
    }

    function sanitizeMoleculeEffectDetails(raw, fallback = {}){
      const source = isPlainObject(raw) ? raw : {};
      const base = isPlainObject(fallback) ? fallback : {};
      const keys = new Set([...Object.keys(base), ...Object.keys(source)]);
      const details = {};
      keys.forEach(key => {
        if (key == null) return;
        const rawValue = source[key] !== undefined ? source[key] : base[key];
        if (rawValue === undefined) return;
        details[key] = sanitizeNumber(rawValue, 0, { integer: true });
      });
      return details;
    }

    function sanitizeMoleculeRequirements(raw, fallback = {}){
      const source = isPlainObject(raw) ? raw : {};
      const base = isPlainObject(fallback) ? fallback : {};
      const requirements = {};
      const awakenValue = source.awakenLevel !== undefined ? source.awakenLevel : base.awakenLevel;
      if (awakenValue !== undefined){
        requirements.awakenLevel = sanitizeNumber(awakenValue, 0, { min: 0, integer: true });
      }
      const familiesSource = Array.isArray(source.familiesComplete)
        ? source.familiesComplete
        : Array.isArray(base.familiesComplete) ? base.familiesComplete : [];
      if (familiesSource.length){
        requirements.familiesComplete = familiesSource
          .map(code => sanitizeString(code, ""))
          .filter(code => code);
      }
      return requirements;
    }

    function sanitizeMoleculeEntry(entry, fallback = {}, index = 0){
      const source = isPlainObject(entry) ? entry : {};
      const fb = isPlainObject(fallback) ? fallback : {};
      const keyFallback = sanitizeString(fb.key, `molecule${index}`);
      const formulaFallback = sanitizeString(fb.formula, keyFallback.toUpperCase());
      const tierFallback = sanitizeString(fb.tier, "common");
      const effectFallback = sanitizeMoleculeEffectDetails(fb.effectDetails, {});
      const reqFallback = sanitizeMoleculeRequirements(fb.requirements, {});
      return {
        key: sanitizeString(source.key, keyFallback),
        formula: sanitizeString(source.formula, formulaFallback),
        tier: sanitizeString(source.tier, tierFallback),
        costIso: sanitizeNumber(source.costIso, fb.costIso ?? 0, { min: 0, integer: true }),
        successChanceScaled: sanitizeNumber(source.successChanceScaled, fb.successChanceScaled ?? 0, { min: 0, max: CHANCE_SCALE, integer: true }),
        effectSummary: sanitizeString(source.effectSummary, sanitizeString(fb.effectSummary, "")),
        effectDetails: sanitizeMoleculeEffectDetails(source.effectDetails, effectFallback),
        requirements: sanitizeMoleculeRequirements(source.requirements, reqFallback)
      };
    }

    function sanitizeFamilyEffects(rawEffects, fallbackEffects = {}){
      const EFFECT_KEYS = [
        "critUnits",
        "apcPercentScaled",
        "apsPercentScaled",
        "apcFlat",
        "apsFlat",
        "offlinePercentScaled",
        "globalPercentScaled",
        "hybridApcScaled",
        "hybridApsScaled",
        "inflationReductionScaled",
        "frenzyBaseIncrement"
      ];
      const MULTIPLIER_KEYS = ["apcMultiplierScale", "apsMultiplierScale", "globalMultiplierScale"];
      const result = { perWeight: {}, setBonus: {} };
      const raw = isPlainObject(rawEffects) ? rawEffects : {};
      const fallback = isPlainObject(fallbackEffects) ? fallbackEffects : {};

      const rawPer = isPlainObject(raw.perWeight) ? raw.perWeight : {};
      const fallbackPer = isPlainObject(fallback.perWeight) ? fallback.perWeight : {};
      const per = {};
      for (const key of EFFECT_KEYS){
        if (fallbackPer[key] !== undefined){
          per[key] = sanitizeNumber(fallbackPer[key], 0);
        }
      }
      for (const key of EFFECT_KEYS){
        if (rawPer[key] !== undefined){
          per[key] = sanitizeNumber(rawPer[key], per[key] ?? 0);
        }
      }

      const rawSet = isPlainObject(raw.setBonus) ? raw.setBonus : {};
      const fallbackSet = isPlainObject(fallback.setBonus) ? fallback.setBonus : {};
      const setBonus = {};
      for (const key of [...EFFECT_KEYS, ...MULTIPLIER_KEYS]){
        if (fallbackSet[key] !== undefined){
          setBonus[key] = sanitizeNumber(fallbackSet[key], 0);
        }
      }
      for (const key of [...EFFECT_KEYS, ...MULTIPLIER_KEYS]){
        if (rawSet[key] !== undefined){
          setBonus[key] = sanitizeNumber(rawSet[key], setBonus[key] ?? 0);
        }
      }

      result.perWeight = per;
      result.setBonus = setBonus;
      return result;
    }

    function sanitizeRarity(entry, fallback = {}, index = 0){
      const base = isPlainObject(entry) ? entry : {};
      const fb = isPlainObject(fallback) ? fallback : {};
      const keyFallback = sanitizeString(fb.key, `rarity${index}`);
      const labelFallback = sanitizeString(fb.label, keyFallback);
      return {
        key: sanitizeString(base.key, keyFallback),
        label: sanitizeString(base.label, labelFallback),
        weight: sanitizeNumber(base.weight, fb.weight ?? 0, { min: 0, integer: true }),
        multiplier: sanitizeNumber(base.multiplier, fb.multiplier ?? 1, { min: 1 })
      };
    }

    function sanitizeAutoTrophy(entry, fallback = {}, index = 0){
      const base = isPlainObject(entry) ? entry : {};
      const fb = isPlainObject(fallback) ? fallback : {};
      const keyFallback = sanitizeString(fb.key, `auto${index + 1}`);
      return {
        key: sanitizeString(base.key, keyFallback),
        threshold: sanitizeNumber(base.threshold, fb.threshold ?? 0, { min: 0, integer: true }),
        name: sanitizeString(base.name, fb.name || keyFallback),
        description: sanitizeString(base.description, fb.description || "")
      };
    }

    const MULTIPLIER_SCALE = getNumberFromConfig(["global", "multiplierScale"], 1000, { min: 1, integer: true });
    const CHANCE_SCALE = getNumberFromConfig(["global", "chanceScale"], 1000, { min: 1, integer: true });

    const DEFAULT_FAMILY_DATA = {
      ALK: {
        label: "Alcalins",
        weight: 7,
        bonusDesc: "+1% chance de crit (max 50%), puis +1% dégâts critiques / bonus (set +5% chance)",
        bonusType: "crit",
        colors: { base: "#f8ead2", owned: "#e3ca9e" },
        effects: {
          perWeight: { critUnits: 1 },
          setBonus: { critUnits: 5 }
        }
      },
      HAL: {
        label: "Halogènes",
        weight: 7,
        bonusDesc: "+1% APC / unique (set +10%)",
        bonusType: "apc",
        colors: { base: "#e0f7f2", owned: "#b6ded0" },
        effects: {
          perWeight: { apcPercentScaled: 10 },
          setBonus: { apcMultiplierScale: 1100 }
        }
      },
      NG: {
        label: "Gaz nobles",
        weight: 7,
        bonusDesc: "+2% APS / unique (set +10%)",
        bonusType: "aps",
        colors: { base: "#f0e7fb", owned: "#cec0ee" },
        effects: {
          perWeight: { apsPercentScaled: 20 },
          setBonus: { apsMultiplierScale: 1100 }
        }
      },
      C: {
        label: "Métaux de transition",
        weight: 40,
        bonusDesc: "+1 APC & APS / élément unique (set +5)",
        bonusType: "flat",
        colors: { base: "#dde8f7", owned: "#b9cbe6" },
        effects: {
          perWeight: { apcFlat: 1, apsFlat: 1 },
          setBonus: { apcFlat: 5, apsFlat: 5 }
        }
      },
      AN: {
        label: "Actinides",
        weight: 15,
        bonusDesc: "+1% APS offline / unique (set +50%)",
        bonusType: "offline",
        colors: { base: "#ffe4e1", owned: "#efb7b2" },
        effects: {
          perWeight: { offlinePercentScaled: 10 },
          setBonus: { offlinePercentScaled: 500 }
        }
      },
      LN: {
        label: "Lanthanides",
        weight: 15,
        bonusDesc: "+0.5% multiplicateur global / unique (set +10%)",
        bonusType: "global",
        colors: { base: "#fbe5f0", owned: "#e3bcd1" },
        effects: {
          perWeight: { globalPercentScaled: 5 },
          setBonus: { globalMultiplierScale: 1100 }
        }
      },
      MET: {
        label: "Métalloïdes",
        weight: 7,
        bonusDesc: "+0.5% APC et APS / unique (set +5%)",
        bonusType: "hybrid",
        colors: { base: "#e8f3ea", owned: "#c7dbce" },
        effects: {
          perWeight: { hybridApcScaled: 5, hybridApsScaled: 5 },
          setBonus: { hybridApcScaled: 50, hybridApsScaled: 50 }
        }
      },
      NM: {
        label: "Non-métaux",
        weight: 2,
        bonusDesc: "-1% coût du tirage par élément + éveil (set -10%)",
        bonusType: "infl",
        colors: { base: "#f3f3f3", owned: "#d8d8d8" },
        effects: {
          perWeight: { inflationReductionScaled: 5 },
          setBonus: { inflationReductionScaled: 100 }
        }
      },
      AE: {
        label: "Alcalino-terreux",
        weight: 7,
        bonusDesc: "Multiplicateur Frénésie : x5 APC +1 par élément/éveil (set +10)",
        bonusType: "frenzy",
        colors: { base: "#e5f2d9", owned: "#c6d8b3" },
        effects: {
          perWeight: { frenzyBaseIncrement: 1 },
          setBonus: { frenzyBaseIncrement: 10 }
        }
      }
    };

    const rawFamilyData = getObjectFromConfig(["families", "definitions"], {});
    const FAMILY_KEYS = new Set([...Object.keys(DEFAULT_FAMILY_DATA), ...Object.keys(rawFamilyData)]);
    const FAMILIES = {};
    const FAMILY_COLORS = {};
    const FAMILY_EFFECTS = {};
    for (const key of FAMILY_KEYS){
      const fallback = DEFAULT_FAMILY_DATA[key] || {
        label: key,
        weight: 1,
        bonusDesc: "",
        bonusType: "custom",
        colors: { base: "#ffffff", owned: "#d8d8d8" },
        effects: { perWeight: {}, setBonus: {} }
      };
      const override = isPlainObject(rawFamilyData[key]) ? rawFamilyData[key] : {};
      const label = sanitizeString(override.label, fallback.label || key);
      const weight = sanitizeNumber(override.weight, fallback.weight ?? 0, { min: 0, integer: true });
      const bonusDesc = sanitizeString(override.bonusDesc, fallback.bonusDesc || "");
      const bonusType = sanitizeString(override.bonusType, fallback.bonusType || "custom");
      const colors = sanitizeColors(override.colors, fallback.colors);
      const effects = sanitizeFamilyEffects(override.effects, fallback.effects);
      FAMILIES[key] = { label, weight, bonusDesc, bonusType };
      FAMILY_COLORS[key] = colors;
      FAMILY_EFFECTS[key] = effects;
    }

    const DEFAULT_CRIT_CONFIG = {
      chancePerUnitScaled: 10,
      maxChanceScaled: 500,
      baseCritDamagePercent: 100,
      extraDamagePerUnit: 1,
      damageThresholdUnits: 50
    };
    const rawCritConfig = getObjectFromConfig(["families", "crit"], {});
    const CRIT_SETTINGS = {
      chancePerUnitScaled: sanitizeNumber(rawCritConfig.chancePerUnitScaled, DEFAULT_CRIT_CONFIG.chancePerUnitScaled, { min: 0, integer: true }),
      maxChanceScaled: sanitizeNumber(rawCritConfig.maxChanceScaled, DEFAULT_CRIT_CONFIG.maxChanceScaled, { min: 0, integer: true }),
      baseCritDamagePercent: sanitizeNumber(rawCritConfig.baseCritDamagePercent, DEFAULT_CRIT_CONFIG.baseCritDamagePercent, { min: 0 }),
      extraDamagePerUnit: sanitizeNumber(rawCritConfig.extraDamagePerUnit, DEFAULT_CRIT_CONFIG.extraDamagePerUnit, { min: 0 }),
      damageThresholdUnits: sanitizeNumber(rawCritConfig.damageThresholdUnits, DEFAULT_CRIT_CONFIG.damageThresholdUnits, { min: 0, integer: true })
    };

    const DEFAULT_RARITIES = [
      { key: "common", label: "Commun", weight: 600, multiplier: 1 },
      { key: "uncommon", label: "Peu commun", weight: 250, multiplier: 2 },
      { key: "rare", label: "Rare", weight: 100, multiplier: 5 },
      { key: "epic", label: "Épique", weight: 40, multiplier: 10 },
      { key: "legendary", label: "Légendaire", weight: 9, multiplier: 25 },
      { key: "mythic", label: "Mythique", weight: 1, multiplier: 100 }
    ];
    const LOOT_RARITIES = (() => {
      const rawList = getArrayFromConfig(["gacha", "rarities"], []);
      const baseList = rawList.length ? rawList : DEFAULT_RARITIES;
      const sanitized = baseList.map((entry, idx) => sanitizeRarity(entry, DEFAULT_RARITIES[idx] || DEFAULT_RARITIES[0], idx));
      if (sanitized.length) return sanitized;
      return DEFAULT_RARITIES.map((entry, idx) => sanitizeRarity(entry, entry, idx));
    })();

    const DEFAULT_AUTO_GACHA_TROPHIES = [
      { key: "auto1", threshold: 1_000_000, name: "Réacteur automatique I", description: "Débloque un tirage gacha gratuit toutes les 10 s sur la page principale." },
      { key: "auto2", threshold: 1_000_000_000, name: "Réacteur automatique II", description: "Réduit l'intervalle des tirages auto à 9 s." },
      { key: "auto3", threshold: 1_000_000_000_000, name: "Réacteur automatique III", description: "Réduit l'intervalle des tirages auto à 8 s." },
      { key: "auto4", threshold: 1_000_000_000_000_000, name: "Réacteur automatique IV", description: "Réduit l'intervalle des tirages auto à 7 s." },
      { key: "auto5", threshold: 1_000_000_000_000_000_000, name: "Réacteur automatique V", description: "Réduit l'intervalle des tirages auto à 6 s." },
      { key: "auto6", threshold: 1_000_000_000_000_000_000_000, name: "Réacteur automatique VI", description: "Réduit l'intervalle des tirages auto à 5 s." }
    ];
    const AUTO_GACHA_TROPHIES = (() => {
      const rawList = getArrayFromConfig(["gacha", "auto", "trophies"], []);
      const baseList = rawList.length ? rawList : DEFAULT_AUTO_GACHA_TROPHIES;
      const sanitized = baseList.map((entry, idx) => sanitizeAutoTrophy(entry, DEFAULT_AUTO_GACHA_TROPHIES[idx] || DEFAULT_AUTO_GACHA_TROPHIES[DEFAULT_AUTO_GACHA_TROPHIES.length - 1], idx));
      return sanitized.length ? sanitized : DEFAULT_AUTO_GACHA_TROPHIES.map((entry, idx) => sanitizeAutoTrophy(entry, entry, idx));
    })();

    const INITIAL_ROLL_COST = getNumberFromConfig(["gacha", "initialRollCost"], 100, { min: 1, integer: true });
    const GACHA_LINEAR_THRESHOLD = getNumberFromConfig(["gacha", "rollCost", "linearThreshold"], 10_000, { min: 1, integer: true });
    const GACHA_LINEAR_INCREMENT = getNumberFromConfig(["gacha", "rollCost", "linearIncrement"], 100, { min: 0, integer: true });
    const GACHA_PERCENT_GROWTH_SCALED = getNumberFromConfig(["gacha", "rollCost", "percentGrowthScaled"], 10, { min: 0 });
    const GACHA_DISCOUNT_CAP_SCALED = getNumberFromConfig(["gacha", "rollCost", "discountCapScaled"], 900, { min: 0, max: MULTIPLIER_SCALE, integer: true });
    const AUTO_GACHA_BASE_INTERVAL = getNumberFromConfig(["gacha", "auto", "baseIntervalSeconds"], 10, { min: 1, integer: true });
    const AUTO_GACHA_INTERVAL_REDUCTION = getNumberFromConfig(["gacha", "auto", "intervalReductionPerTier"], 1, { min: 0, integer: true });
    const AUTO_GACHA_MIN_INTERVAL = getNumberFromConfig(["gacha", "auto", "minIntervalSeconds"], 5, { min: 1, integer: true });

    const DEFAULT_MOLECULE_TIERS = [
      { key: "common", label: "Commune", color: "#6aa3ff" },
      { key: "rare", label: "Rare", color: "#9b5de5" },
      { key: "epic", label: "Épique", color: "#ef476f" }
    ];

    const MOLECULE_TIERS = (() => {
      const rawList = getArrayFromConfig(["molecules", "tiers"], []);
      const baseList = rawList.length ? rawList : DEFAULT_MOLECULE_TIERS;
      const sanitized = baseList.map((entry, idx) => {
        const fallback = DEFAULT_MOLECULE_TIERS[idx] || DEFAULT_MOLECULE_TIERS[DEFAULT_MOLECULE_TIERS.length - 1] || {};
        const source = isPlainObject(entry) ? entry : {};
        const key = sanitizeString(source.key, sanitizeString(fallback.key, `tier${idx}`));
        return {
          key,
          label: sanitizeString(source.label, sanitizeString(fallback.label, key)),
          color: sanitizeColorValue(source.color, sanitizeColorValue(fallback.color, ""))
        };
      }).filter(tier => tier.key);
      const seen = new Set();
      return sanitized.filter(tier => {
        if (seen.has(tier.key)) return false;
        seen.add(tier.key);
        return true;
      });
    })();

    const MOLECULE_UNLOCK = (() => {
      const raw = getObjectFromConfig(["molecules", "unlock"], {});
      return {
        requiredRevives: sanitizeNumber(raw.requiredRevives, 0, { min: 0, integer: true }),
        requiresFullTable: raw.requiresFullTable === true,
        finalQuestKey: sanitizeString(raw.finalQuestKey, "")
      };
    })();

    const MOLECULE_FUSION = (() => {
      const raw = getObjectFromConfig(["molecules", "fusion"], {});
      const catalyst = isPlainObject(raw.catalystCost) ? raw.catalystCost : {};
      return {
        residueRefundPercent: sanitizeNumber(raw.residueRefundPercent, 0, { min: 0, integer: true }),
        pityStepPercent: sanitizeNumber(raw.pityStepPercent, 0, { min: 0, integer: true }),
        maxPityPercent: sanitizeNumber(raw.maxPityPercent, 0, { min: 0, integer: true }),
        catalystBonusPercent: sanitizeNumber(raw.catalystBonusPercent, 0, { min: 0, integer: true }),
        catalystCost: {
          resource: sanitizeString(catalyst.resource, ""),
          amount: sanitizeNumber(catalyst.amount, 0, { min: 0, integer: true })
        }
      };
    })();

    const MOLECULE_LIST = (() => {
      const rawList = getArrayFromConfig(["molecules", "list"], []);
      if (!rawList.length) return [];
      return rawList
        .map((entry, idx) => sanitizeMoleculeEntry(entry, entry, idx))
        .filter(entry => entry.key && entry.tier);
    })();

    const MOLECULE_BY_KEY = MOLECULE_LIST.reduce((map, molecule) => {
      map[molecule.key] = molecule;
      return map;
    }, {});

    const MOLECULES_BY_TIER = (() => {
      const grouped = new Map();
      for (const molecule of MOLECULE_LIST){
        if (!grouped.has(molecule.tier)) grouped.set(molecule.tier, []);
        grouped.get(molecule.tier).push(molecule);
      }
      for (const list of grouped.values()){
        list.sort((a, b) => {
          if (a.costIso !== b.costIso) return a.costIso - b.costIso;
          return a.key.localeCompare(b.key);
        });
      }
      return grouped;
    })();

    const MOLECULE_RARITY_FAMILY_GROUPS = {
      common: ["C", "NM", "AE"],
      rare: ["MET", "HAL", "LN"],
      epic: ["AN", "NG", "ALK"]
    };

    const MOLECULE_PITY_STEP_SCALED = Math.max(0, Math.floor(MOLECULE_FUSION.pityStepPercent || 0));
    const MOLECULE_MAX_PITY_SCALED = Math.max(0, Math.floor(MOLECULE_FUSION.maxPityPercent || 0));
    const MOLECULE_RESIDUE_REFUND_SCALED = Math.max(0, Math.floor(MOLECULE_FUSION.residueRefundPercent || 0));

    const AWAKEN_MAX = getNumberFromConfig(["awaken", "maxLevel"], 100, { min: 1, integer: true });
    const AWAKEN_FINAL_COST = getNumberFromConfig(["awaken", "finalCost"], 1_000_000, { min: 1, integer: true });
    const AWAKEN_BASE_COSTS = (() => {
      const raw = getArrayFromConfig(["awaken", "baseCosts"], []);
      const base = raw.length ? raw : [5, 10, 25, 50];
      const sanitized = base.map(value => sanitizeNumber(value, 0, { min: 1, integer: true })).filter(value => value > 0);
      return sanitized.length ? sanitized : [5, 10, 25, 50];
    })();
    const AWAKEN_DISCOUNT_STEP = getNumberFromConfig(["awaken", "discountStep"], 50, { min: 0, integer: true });
    const AWAKEN_DISCOUNT_RATIO = getNumberFromConfig(["awaken", "discountRatio"], 0.99, { min: 0, max: 1 });
    const AWAKEN_MULTIPLIER_BASE = getNumberFromConfig(["awaken", "multiplierBase"], 2, { min: Number.EPSILON });
    const AWAKEN_COSTS = (() => {
      const costs = AWAKEN_BASE_COSTS.slice(0, AWAKEN_MAX);
      if (costs.length === 0) costs.push(5);
      let remaining = Math.max(0, AWAKEN_MAX - costs.length);
      let prev = costs[costs.length - 1];
      while (remaining > 0){
        const ratio = Math.pow(AWAKEN_FINAL_COST / prev, 1 / remaining);
        const maxAllowed = AWAKEN_FINAL_COST - (remaining - 1) * 5;
        let next = prev * ratio;
        next = Math.round(next / 5) * 5;
        if (next > maxAllowed) next = maxAllowed;
        if (next <= prev) next = prev + 5;
        costs.push(Math.round(next));
        remaining--;
        prev = next;
      }
      costs[costs.length - 1] = AWAKEN_FINAL_COST;
      return costs;
    })();

    const FRENZY_BASE_MULTIPLIER = getNumberFromConfig(["frenzy", "baseMultiplier"], 5, { min: 1 });
    const APC_FRENZY_DURATION_MS = getNumberFromConfig(["frenzy", "apcDurationMs"], 30_000, { min: 1, integer: true });
    const APS_FRENZY_DURATION_MS = getNumberFromConfig(["frenzy", "apsDurationMs"], 60_000, { min: 1, integer: true });
    const FRENZY_SPAWN_DENOM = getNumberFromConfig(["frenzy", "spawnDenominator"], 120, { min: 1, integer: true });
    const FRENZY_ORB_LIFETIME_MS = getNumberFromConfig(["frenzy", "orbLifetimeMs"], 8_000, { min: 1, integer: true });

    const REVIVE_BASE_COST = getNumberFromConfig(["revive", "baseCost"], 1_000_000_000_000, { min: 1, integer: true });
    const REVIVE_COST_MULTIPLIER = getNumberFromConfig(["revive", "costMultiplier"], 1000, { min: 1 });
    const REVIVE_REWARDS = (() => {
      const raw = getArrayFromConfig(["revive", "rewards"], []);
      const base = raw.length ? raw : [200, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500];
      const sanitized = base.map(value => sanitizeNumber(value, 0, { min: 0, integer: true })).filter(value => value > 0);
      return sanitized.length ? sanitized : [200, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500];
    })();
    const REVIVE_EXTRA_REWARD_STEP = getNumberFromConfig(["revive", "extraRewardStep"], 500, { min: 0, integer: true });

    // Liste des métalloïdes classiques
    const METALLOIDS = new Set(["B","Si","Ge","As","Sb","Te","Po"]);

    // Noms FR (si un manque, on affichera le symbole)
    const NAMES_FR = {
      H:"Hydrogène", He:"Hélium", Li:"Lithium", Be:"Béryllium", B:"Bore", C:"Carbone", N:"Azote", O:"Oxygène", F:"Fluor", Ne:"Néon",
      Na:"Sodium", Mg:"Magnésium", Al:"Aluminium", Si:"Silicium", P:"Phosphore", S:"Soufre", Cl:"Chlore", Ar:"Argon",
      K:"Potassium", Ca:"Calcium", Sc:"Scandium", Ti:"Titane", V:"Vanadium", Cr:"Chrome", Mn:"Manganèse", Fe:"Fer", Co:"Cobalt", Ni:"Nickel", Cu:"Cuivre", Zn:"Zinc", Ga:"Gallium", Ge:"Germanium", As:"Arsenic", Se:"Sélénium", Br:"Brome", Kr:"Krypton",
      Rb:"Rubidium", Sr:"Strontium", Y:"Yttrium", Zr:"Zirconium", Nb:"Niobium", Mo:"Molybdène", Tc:"Technétium", Ru:"Ruthénium", Rh:"Rhodium", Pd:"Palladium", Ag:"Argent", Cd:"Cadmium", In:"Indium", Sn:"Étain", Sb:"Antimoine", Te:"Tellure", I:"Iode", Xe:"Xénon",
      Cs:"Césium", Ba:"Baryum", La:"Lanthane", Ce:"Cérium", Pr:"Praséodyme", Nd:"Néodyme", Pm:"Prométhium", Sm:"Samarium", Eu:"Europium", Gd:"Gadolinium", Tb:"Terbium", Dy:"Dysprosium", Ho:"Holmium", Er:"Erbium", Tm:"Thulium", Yb:"Ytterbium", Lu:"Lutécium",
      Hf:"Hafnium", Ta:"Tantale", W:"Tungstène", Re:"Rhénium", Os:"Osmium", Ir:"Iridium", Pt:"Platine", Au:"Or", Hg:"Mercure", Tl:"Thallium", Pb:"Plomb", Bi:"Bismuth", Po:"Polonium", At:"Astate", Rn:"Radon",
      Fr:"Francium", Ra:"Radium", Ac:"Actinium", Th:"Thorium", Pa:"Protactinium", U:"Uranium", Np:"Neptunium", Pu:"Plutonium", Am:"Américium", Cm:"Curium", Bk:"Berkélium", Cf:"Californium", Es:"Einsteinium", Fm:"Fermium", Md:"Mendélévium", No:"Nobélium", Lr:"Lawrencium",
      Rf:"Rutherfordium", Db:"Dubnium", Sg:"Seaborgium", Bh:"Bohrium", Hs:"Hassium", Mt:"Meitnérium", Ds:"Darmstadtium", Rg:"Roentgenium", Cn:"Copernicium", Nh:"Nihonium", Fl:"Flérovium", Mc:"Moscovium", Lv:"Livermorium", Ts:"Tennessine", Og:"Oganesson"
    };

    // Ordre officiel des 118 éléments (numéros atomiques croissants)
    // Source de référence : https://fr.periodic-table.io/
    const ORDERED_SYMBOLS = [
      "H","He","Li","Be","B","C","N","O","F","Ne",
      "Na","Mg","Al","Si","P","S","Cl","Ar",
      "K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn",
      "Ga","Ge","As","Se","Br","Kr",
      "Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd",
      "In","Sn","Sb","Te","I","Xe",
      "Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu",
      "Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn",
      "Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr",
      "Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
    ];

    const ATOMIC_NUMBERS = ORDERED_SYMBOLS.reduce((map, symbol, idx) => {
      map[symbol] = idx + 1;
      return map;
    }, {});

    // Tableau périodique : périodes 1–7 (grille 18 colonnes)
    // Chaque ligne est un tableau de 18 symboles ("" = vide, "*" = emplacement de série f)
    const PERIODS = {
      1: ["H","","","","","","","","","","","","","","","","","He"],
      2: ["Li","Be","","","","","","","","","","","B","C","N","O","F","Ne"],
      3: ["Na","Mg","","","","","","","","","","","Al","Si","P","S","Cl","Ar"],
      4: ["K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr"],
      5: ["Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe"],
      6: ["Cs","Ba","*","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn"],
      7: ["Fr","Ra","*","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"]
    };

    // Séries f (Lanthanides & Actinides), 15 éléments chacune, placées en rangées séparées
    const LANTHANIDES = ["La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu"];
    const ACTINIDES   = ["Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"];

    // Famille calculée selon groupe/période
    function familyOf(symbol, row, col){
      // Lanthanides / Actinides
      if (LANTHANIDES.includes(symbol)) return "LN";
      if (ACTINIDES.includes(symbol)) return "AN";
      // Groupes
      if (col===18) return "NG";
      if (col===17) return "HAL";
      if (col===1 && symbol!=="H") return "ALK";
      if (col===2) return "AE";
      // Métalloïdes
      if (METALLOIDS.has(symbol)) return "MET";
      // Non-métaux "classiques"
      if (["H","C","N","O","P","S","Se"].includes(symbol)) return "NM";
      // Métaux de transition (3–12) + autres métaux -> range dans C par simplicité de bonus
      if (col>=3 && col<=12) return "C";
      // Post-transition (13–16) => range dans C également pour ce design
      if (col>=13 && col<=16) return METALLOIDS.has(symbol) ? "MET" : "C";
      return "C";
    }

    function blockOf(symbol, period, col){
      if (LANTHANIDES.includes(symbol) || ACTINIDES.includes(symbol)) return "f";
      if (col <= 2) return "s";
      if (col >= 13) return "p";
      return "d";
    }

    // Construction de la liste complète 118 avec positions
    const ELEMENTS = [];
    for (let period=1; period<=7; period++){
      const row = PERIODS[period];
      for (let c=1; c<=18; c++){
        const sym = row[c-1] || "";
        if (!sym || sym==="*") continue;
        const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
        const family = familyOf(sym, period, c);
        const block = blockOf(sym, period, c);
        ELEMENTS.push({ Z, symbol: sym, name: NAMES_FR[sym]||sym, family, period, col:c, block });
      }
    }
    // Ajoute lanthanides (col 4 -> 18)
    LANTHANIDES.forEach((sym,i)=>{
      const col = 4 + i;
      const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
      ELEMENTS.push({ Z, symbol:sym, name:NAMES_FR[sym]||sym, family:"LN", period:6, col, block:"f", frow:"lan" });
    });
    // Ajoute actinides (col 4 -> 18)
    ACTINIDES.forEach((sym,i)=>{
      const col = 4 + i;
      const Z = ATOMIC_NUMBERS[sym] ?? (ELEMENTS.length + 1);
      ELEMENTS.push({ Z, symbol:sym, name:NAMES_FR[sym]||sym, family:"AN", period:7, col, block:"f", frow:"act" });
    });

    if (ELEMENTS.length !== ORDERED_SYMBOLS.length){
      console.warn(`[PeriodicTable] ${ELEMENTS.length} éléments chargés (attendu ${ORDERED_SYMBOLS.length}).`);
    }

    const ELEMENT_BY_SYMBOL = ELEMENTS.reduce((map, el)=>{
      map[el.symbol] = el;
      return map;
    }, {});

    // Tailles de set (pour les bonus de “set complet”)
    const FAMILY_SET_SIZES = {};
    for (const f of Object.keys(FAMILIES)) FAMILY_SET_SIZES[f] = ELEMENTS.filter(e=>e.family===f && !e.frow).length
      + (f==="LN"?LANTHANIDES.length:0) + (f==="AN"?ACTINIDES.length:0);

    /* ===================== État & persistance ===================== */
    const S0 = JSON.parse(localStorage.getItem("miniAtomState") || "{}");
    let atoms = toNonNegativeInt(S0.atoms ?? 0);
    let baseApc = Math.max(1, toNonNegativeInt(S0.apc ?? 1));
    let baseAps = toNonNegativeInt(S0.aps ?? 0);
    let apcLvl = toNonNegativeInt(S0.apcLvl ?? 0);
    let autoLvl = toNonNegativeInt(S0.autoLvl ?? 0);
    let apcMultiLvl = toNonNegativeInt(S0.apcMultiLvl ?? 0);
    let apsMultiLvl = toNonNegativeInt(S0.apsMultiLvl ?? 0);
    let totalAtoms = toNonNegativeInt(S0.totalAtoms ?? atoms);
    let manualClicksTotal = toNonNegativeInt(S0.manualClicks ?? 0);
    let reviveCount = toNonNegativeInt(S0.reviveCount ?? 0);
    let reviveRunAtoms = toNonNegativeInt(S0.reviveAtoms ?? totalAtoms);
    let reviveRunClicks = toNonNegativeInt(S0.reviveClicks ?? manualClicksTotal);
    let reviveUnlocked = (S0.reviveUnlocked === true) || reviveCount > 0;
    let gameStart = Number.isFinite(S0.gameStart) ? Math.max(0, Math.floor(S0.gameStart)) : Date.now();
    const reviveBaseValues = getReviveBaseStartValue(reviveCount);
    if (reviveBaseValues){
      baseApc = Math.max(baseApc, reviveBaseValues.apc);
      baseAps = Math.max(baseAps, reviveBaseValues.aps);
    }
    let trophies = {};
    if (S0.trophies && typeof S0.trophies === "object"){
      for (const trophy of AUTO_GACHA_TROPHIES){
        if (S0.trophies[trophy.key]) trophies[trophy.key] = S0.trophies[trophy.key];
      }
    }
    let last = S0.last ?? null;
    let sessionStartTime = Date.now();
    let sessionManualClicks = 0;
    let sessionAtomsGained = 0;
    let apcFrenzyEffects = [];
    let apsFrenzyEffects = [];
    let currentFrenzyMultiplierBase = Math.max(1, FRENZY_BASE_MULTIPLIER);
    let apcFrenzyOrbTimeout = null;
    let apsFrenzyOrbTimeout = null;
    let apcFrenzyOrbVisible = false;
    let apsFrenzyOrbVisible = false;
    let autoGachaCooldown = 0;
    let lastAutoResult = null;

    // Gacha/collection
    function createDefaultMoleculeProgress(){
      return {
        unlocked: {},
        pityScaled: {},
        dust: 0,
        residue: 0,
        lastResult: null
      };
    }

    function sanitizeMoleculeProgress(raw){
      const base = createDefaultMoleculeProgress();
      if (!raw || typeof raw !== "object") return base;
      if (raw.unlocked && typeof raw.unlocked === "object"){
        for (const [key, value] of Object.entries(raw.unlocked)){
          if (!value) continue;
          if (MOLECULE_BY_KEY[key]) base.unlocked[key] = true;
        }
      }
      if (raw.pityScaled && typeof raw.pityScaled === "object"){
        for (const [tier, value] of Object.entries(raw.pityScaled)){
          base.pityScaled[tier] = Math.max(0, Math.min(CHANCE_SCALE, Math.floor(value || 0)));
        }
      }
      if (raw.dust !== undefined) base.dust = Math.max(0, Math.floor(raw.dust));
      if (raw.residue !== undefined) base.residue = Math.max(0, Math.floor(raw.residue));
      if (raw.lastResult && typeof raw.lastResult === "object"){
        base.lastResult = {
          key: sanitizeString(raw.lastResult.key, ""),
          success: raw.lastResult.success === true,
          timestamp: Math.max(0, Math.floor(raw.lastResult.timestamp || Date.now())),
          message: sanitizeString(raw.lastResult.message, "")
        };
      }
      return base;
    }

    function createDefaultGachaState(){
      return {
        pulls: 0,
        isotopes: 0,
        owned: {},   // symbol -> 0/1
        dupes: {},   // symbol -> n
        isoStock: {}, // symbol -> isotopes accumulés
        awakens: {},  // symbol -> niveau d'éveil
        awakenCount: 0,
        rollCost: INITIAL_ROLL_COST, // coût actuel d’un tirage (Atoms)
        molecules: createDefaultMoleculeProgress()
      };
    }
    const G0 = JSON.parse(localStorage.getItem("gacha") || "{}");
    let gacha = createDefaultGachaState();
    gacha = Object.assign(gacha, G0);
    gacha.rollCost = Math.max(1, toNonNegativeInt(gacha.rollCost ?? INITIAL_ROLL_COST));
    gacha.pulls = toNonNegativeInt(gacha.pulls || 0);

    if (!gacha.isoStock || typeof gacha.isoStock !== "object") gacha.isoStock = {};
    if (!gacha.awakens || typeof gacha.awakens !== "object") gacha.awakens = {};
    if (!gacha.molecules || typeof gacha.molecules !== "object") gacha.molecules = createDefaultMoleculeProgress();
    else gacha.molecules = sanitizeMoleculeProgress(gacha.molecules);

    if (G0.isoStock){
      for (const [sym, amt] of Object.entries(G0.isoStock)){
        gacha.isoStock[sym] = Math.max(0, Math.floor(amt));
      }
    }

    let awakenCountFromLevels = 0;
    for (const [sym, lvl] of Object.entries(gacha.awakens)){
      const sanitizedLevel = Math.min(AWAKEN_MAX, Math.max(0, Math.floor(lvl)));
      gacha.awakens[sym] = sanitizedLevel;
      awakenCountFromLevels += sanitizedLevel;
    }
    const storedAwakenCount = toNonNegativeInt(gacha.awakenCount || 0);
    gacha.awakenCount = Math.max(storedAwakenCount, awakenCountFromLevels);
    syncTotalIsotopes();

    // Thème

    function saveAll(){
      localStorage.setItem("miniAtomState", JSON.stringify({
        atoms,
        apc: baseApc,
        aps: baseAps,
        apcLvl,
        autoLvl,
        apcMultiLvl,
        apsMultiLvl,
        totalAtoms,
        trophies,
        manualClicks: manualClicksTotal,
        gameStart,
        last: Date.now(),
        reviveCount,
        reviveAtoms: reviveRunAtoms,
        reviveClicks: reviveRunClicks,
        reviveUnlocked
      }));
      localStorage.setItem("gacha", JSON.stringify(gacha));
    }

    /* ===================== UI refs ===================== */

    const atomIcon = document.getElementById("atomIcon");
    const confettiLayer = document.getElementById("confettiLayer");
    const mainPageEl = document.getElementById("mainPage");
    const shopPageEl = document.getElementById("shopPage");
    const gachaPageEl = document.getElementById("gachaPage");
    const moleculesPageEl = document.getElementById("moleculesPage");
    const infosPageEl = document.getElementById("infosPage");
    const revivePageEl = document.getElementById("revivePage");
    const optionsPageEl = document.getElementById("optionsPage");
    const navButtons = Array.from(document.querySelectorAll(".nav-button[data-page-target]"));
    const reviveNavButton = navButtons.find(btn => btn.dataset.pageTarget === "revivePage");

    const reviveOfferEl = document.getElementById("reviveOffer");
    const reviveBuyBtn = document.getElementById("reviveBuyBtn");
    const reviveCostValueEl = document.getElementById("reviveCostValue");
    const reviveRewardValueEl = document.getElementById("reviveRewardValue");
    const reviveLockedMessageEl = document.getElementById("reviveLockedMessage");
    const reviveCountStatEl = document.getElementById("reviveCountStat");
    const reviveBaseStatEl = document.getElementById("reviveBaseStat");
    const reviveShopStatEl = document.getElementById("reviveShopStat");

    const elAtoms = document.getElementById("atoms");
    const elAps = document.getElementById("aps");
    const elApc = document.getElementById("apc");

    const elAtomsShop = document.getElementById("atomsShop");
    const elApsShop = document.getElementById("apsShop");
    const elApcShop = document.getElementById("apcShop");

    const elAtomsGacha = document.getElementById("atomsGacha");
    const elApsGacha = document.getElementById("apsGacha");
    const elApcGacha = document.getElementById("apcGacha");

    const btnBuyApc = document.getElementById("buyApc");
    const btnBuyApc10 = document.getElementById("buyApc10");
    const btnBuyApc100 = document.getElementById("buyApc100");
    const btnBuyAuto = document.getElementById("buyAuto");
    const btnBuyAuto10 = document.getElementById("buyAuto10");
    const btnBuyAuto100 = document.getElementById("buyAuto100");
    const btnBuyApcMulti = document.getElementById("buyApcMulti");
    const btnBuyApsMulti = document.getElementById("buyApsMulti");
    const infoApc = document.getElementById("apcInfo");
    const infoAuto = document.getElementById("autoInfo");
    const infoApcMulti = document.getElementById("apcMultiInfo");
    const infoApsMulti = document.getElementById("apsMultiInfo");

    const rollBtn = document.getElementById("rollBtn");
    const roll10Btn = document.getElementById("roll10Btn");
    const roll100Btn = document.getElementById("roll100Btn");
    const rollCostOnBtn = document.getElementById("rollCostOnBtn");
    const roll10CostOnBtn = document.getElementById("roll10Cost");
    const roll100CostOnBtn = document.getElementById("roll100Cost");
    const isotopesEl = document.getElementById("isotopes");

    const moleculeIsoStockEl = document.getElementById("moleculeIsoStock");
    const moleculeDustEl = document.getElementById("moleculeDust");
    const moleculeListEl = document.getElementById("moleculeList");
    const moleculeNoticeEl = document.getElementById("moleculeUnlockNotice");
    const moleculeResultEl = document.getElementById("moleculeLastResult");

    const gridMain = document.getElementById("periodicGrid");
    const gachaInfoPanel = document.getElementById("gachaInfo");
    const awakenDiscountCounter = document.getElementById("awakenDiscountCounter");

    const elementName = document.getElementById("elementName");
    const elementIsoCount = document.getElementById("elementIsoCount");
    const elementFamily = document.getElementById("elementFamily");
    const awakenBtn = document.getElementById("awakenBtn");
    const awakenAllBtn = document.getElementById("awakenAllBtn");
    const awakenWrapper = document.getElementById("awakenWrapper");
    const awakenSingleCard = document.getElementById("awakenSingleCard");
    const awakenAllCard = document.getElementById("awakenAllCard");
    if (awakenAllBtn) awakenAllBtn.setAttribute("aria-label", "Éveiller tous les éléments possédés");

    const infosBonusLinesEl = document.getElementById("infosBonusLines");
    const infosBonusEmptyEl = document.getElementById("infosBonusEmpty");
    const infosSetStatusEl = document.getElementById("infosSetStatus");
    const infosSetEmptyEl = document.getElementById("infosSetEmpty");
    const infosTrophyListEl = document.getElementById("infosTrophyList");
    const infosTrophyEmptyEl = document.getElementById("infosTrophyEmpty");
    const infosMoleculeListEl = document.getElementById("infosMoleculeList");
    const infosMoleculeEmptyEl = document.getElementById("infosMoleculeEmpty");

    const infosSessionAtomsEl = document.getElementById("infosSessionAtoms");
    const infosSessionClicksEl = document.getElementById("infosSessionClicks");
    const infosSessionDurationEl = document.getElementById("infosSessionDuration");
    const infosReviveAtomsEl = document.getElementById("infosReviveAtoms");
    const infosLifetimeAtomsEl = document.getElementById("infosLifetimeAtoms");
    const infosReviveClicksEl = document.getElementById("infosReviveClicks");
    const infosLifetimeClicksEl = document.getElementById("infosLifetimeClicks");
    const infosReviveCountEl = document.getElementById("infosReviveCount");
    const infosTotalRuntimeEl = document.getElementById("infosTotalRuntime");
    const infosApcBaseEl = document.getElementById("infosApcBase");
    const infosApcFlatEl = document.getElementById("infosApcFlat");
    const infosApcAfterFlatEl = document.getElementById("infosApcAfterFlat");
    const infosApcMultipliersEl = document.getElementById("infosApcMultipliers");
    const infosApcTotalEl = document.getElementById("infosApcTotal");
    const infosApsBaseEl = document.getElementById("infosApsBase");
    const infosApsFlatEl = document.getElementById("infosApsFlat");
    const infosApsAfterFlatEl = document.getElementById("infosApsAfterFlat");
    const infosApsMultipliersEl = document.getElementById("infosApsMultipliers");
    const infosApsTotalEl = document.getElementById("infosApsTotal");

    const resetBtn = document.getElementById("resetBtn");
    const resetModal = document.getElementById("resetModal");
    const resetWordEl = document.getElementById("resetWord");
    const resetInput = document.getElementById("resetInput");
    const resetConfirmBtn = document.getElementById("confirmReset");
    const resetCancelBtn = document.getElementById("cancelReset");
    const resetCloseBtn = document.getElementById("closeReset");

    const lastLootBox = document.getElementById("lastLootBox");
    const lastLootName = document.getElementById("lastLootName");
    const lastLootFam = document.getElementById("lastLootFam");
    const lastLootType = document.getElementById("lastLootType");
    const apcFrenzyStatusEl = document.getElementById("apcFrenzyStatus");
    const apsFrenzyStatusEl = document.getElementById("apsFrenzyStatus");
    const apcFrenzyOrbEl = document.getElementById("frenzyOrb");
    const apsFrenzyOrbEl = document.getElementById("apsFrenzyOrb");
    const autoGachaPanel = document.getElementById("autoGachaPanel");
    const autoGachaHeader = document.getElementById("autoGachaHeader");
    const autoGachaName = document.getElementById("autoGachaName");
    const autoGachaResultEl = document.getElementById("autoGachaResult");

    function setLootResultClass(cls, target = lastLootType){
      if (!target) return;
      const baseClass = target.dataset.baseClass || "loot-result";
      target.className = baseClass;
      if (cls) target.classList.add(cls);
    }

    const themeButtons = Array.from(document.querySelectorAll('#themeControls button'));

    const CONFETTI_LIFETIME = 2500;
    const CONFETTI_COUNT = 36;
    const CONFETTI_PALETTES = {
      dark: ['#fff3b0','#ffadad','#cdb4db','#90f1ef','#ffd6a5','#f9f871'],
      light: ['#5f0f40','#9a031e','#fb8b24','#0f4c5c','#335c67','#3a86ff'],
      rainbow: ['#ff595e','#ffca3a','#8ac926','#1982c4','#6a4c93','#ff924c']
    };

    let currentTheme = null;
    let currentElement = null;
    let currentIsoDiscount = 0;
    let currentRollDiscount = 0;
    const cellMap = new Map();
    let currentResetWord = "";
    let critFlashTimeout = null;

    function createSoundPlayer(src, { poolSize = 4, volume = 1 } = {}){
      const players = [];
      for (let i = 0; i < poolSize; i++){
        const audio = new Audio(src);
        audio.preload = "auto";
        audio.volume = volume;
        audio.load();
        players.push(audio);
      }
      let nextIndex = 0;
      return function play(){
        if (!players.length) return;
        const audio = players[nextIndex];
        nextIndex = (nextIndex + 1) % players.length;
        try {
          audio.currentTime = 0;
          const playPromise = audio.play();
          if (playPromise && typeof playPromise.catch === "function"){
            playPromise.catch(()=>{});
          }
        } catch (err) {
          /* ignore playback errors (autoplay restrictions, etc.) */
        }
      };
    }

    const playPopSound = createSoundPlayer("Assets/Sounds/pop.mp3", { poolSize:6, volume:0.45 });
    const playCritSound = createSoundPlayer("Assets/Sounds/crit.mp3", { poolSize:3, volume:0.6 });


    // Thème (après récupération des boutons pour éviter les erreurs à l'initialisation)
    const savedTheme = localStorage.getItem("theme") || "rainbow";
    currentTheme = savedTheme;
    function applyTheme(theme, { persist = true } = {}){
      document.body.classList.remove("theme-light","theme-dark","theme-rainbow");
      document.body.classList.add(`theme-${theme}`);
      if (persist) localStorage.setItem("theme", theme);
      themeButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.theme === theme));
      currentTheme = theme;
    }
    applyTheme(savedTheme, { persist:false });


    /* ===================== Helpers ===================== */
    const ValueMath = (()=>{
      const ensureNumber = value => {
        if (typeof value === "number") return Number.isNaN(value) ? 0 : value;
        const num = Number(value);
        return Number.isNaN(num) ? 0 : num;
      };
      const finalize = value => Number.isNaN(value) ? 0 : value;
      const from = value => ensureNumber(value);
      const toNumber = value => ensureNumber(value);
      const add = (a, b) => finalize(ensureNumber(a) + ensureNumber(b));
      const sub = (a, b) => finalize(ensureNumber(a) - ensureNumber(b));
      const mul = (a, b) => finalize(ensureNumber(a) * ensureNumber(b));
      const divScale = (value, multiplier, scale = MULTIPLIER_SCALE, { round = "floor" } = {}) => {
        const base = ensureNumber(value);
        const mult = ensureNumber(multiplier);
        const scaleValue = ensureNumber(scale);
        if (scaleValue === 0) return 0;
        const raw = (base * mult) / scaleValue;
        if (Number.isNaN(raw)) return 0;
        if (!Number.isFinite(raw)) return raw;
        if (round === "none") return raw;
        if (round === "ceil") return Math.ceil(raw);
        if (round === "round") return Math.round(raw);
        return Math.floor(raw);
      };
      const clampSafe = (value, { min = 0, max = Number.POSITIVE_INFINITY } = {}) => {
        const num = ensureNumber(value);
        if (!Number.isFinite(num)) return num > 0 ? max : min;
        if (num < min) return min;
        if (num > max) return max;
        return num;
      };
      const compare = (a, b) => {
        const left = ensureNumber(a);
        const right = ensureNumber(b);
        if (left < right) return -1;
        if (left > right) return 1;
        return 0;
      };
      const isZero = value => ensureNumber(value) === 0;
      const abs = value => finalize(Math.abs(ensureNumber(value)));
      const splitThousands = value => {
        const groups = [];
        const absolute = abs(value);
        if (!Number.isFinite(absolute)) return [0];
        let remaining = Math.floor(absolute);
        if (!Number.isFinite(remaining) || remaining < 0) remaining = 0;
        if (remaining === 0) return [0];
        while (remaining >= 1000){
          const chunk = remaining % 1000;
          groups.push(chunk);
          remaining = Math.floor(remaining / 1000);
        }
        groups.push(remaining);
        return groups.reverse();
      };
      const toMantissaExponent = (value, base = 10) => {
        const num = ensureNumber(value);
        const rawBase = Math.abs(ensureNumber(base));
        const safeBase = !Number.isFinite(rawBase) || rawBase < 2 ? 10 : rawBase;
        if (num === 0) return { mantissa: 0, exponent: 0 };
        if (!Number.isFinite(num)) return { mantissa: num, exponent: 0 };
        const exponent = Math.floor(Math.log(Math.abs(num)) / Math.log(safeBase));
        const power = Math.pow(safeBase, exponent);
        if (power === 0 || !Number.isFinite(power)) return { mantissa: num, exponent };
        const mantissa = finalize(num / power);
        return { mantissa, exponent };
      };
      const format = value => formatNumber(ensureNumber(value));
      return {
        from,
        toNumber,
        add,
        sub,
        mul,
        divScale,
        clampSafe,
        compare,
        isZero,
        format,
        abs,
        splitThousands,
        toMantissaExponent
      };
    })();

    const RESET_WORDS = [
      "quantique","neutron","proton","orbite","fusion","plasma","noyau","isotope","photon","boson","quark","ion"
    ];

    const SUFFIXES = (()=>{
      const list = ["", "m", "b", "t"];
      const prefixes = ["S","T","U","V","W","X","Y","Z"];
      for (const prefix of prefixes){
        for (let i = 0; i < 26; i++){
          list.push(`${prefix}${String.fromCharCode(97 + i)}`);
        }
      }
      return list;
    })();

    function toInteger(value){
      if (!Number.isFinite(value)) return 0;
      return value >= 0 ? Math.floor(value) : Math.ceil(value);
    }

    function toNonNegativeInt(value){
      const intVal = toInteger(value);
      return intVal < 0 ? 0 : intVal;
    }

    function checkReviveUnlock(){
      if (!reviveUnlocked && atoms >= getReviveCostValue(0)){
        reviveUnlocked = true;
        updateReviveNavState();
        updateReviveUI();
      }
    }

    function addAtoms(amount, { silent = false } = {}){
      const gain = ValueMath.clampSafe(toNonNegativeInt(amount));
      if (!gain) return false;
      atoms = ValueMath.clampSafe(ValueMath.add(atoms, gain));
      totalAtoms = ValueMath.clampSafe(ValueMath.add(totalAtoms, gain));
      reviveRunAtoms = ValueMath.clampSafe(ValueMath.add(reviveRunAtoms, gain));
      const nextSessionGain = ValueMath.add(sessionAtomsGained, gain);
      sessionAtomsGained = nextSessionGain >= Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : nextSessionGain;
      checkReviveUnlock();
      checkTrophies({ silent });
      return true;
    }

    function splitIntoGroups(value){
      const groups = ValueMath.splitThousands(value);
      if (!Array.isArray(groups) || groups.length === 0) return [0];
      return groups;
    }

    function joinGroups(groups){
      if (!Array.isArray(groups) || groups.length === 0) return '0';
      return groups.map((group, idx) => {
        const sanitized = ValueMath.splitThousands(group);
        const value = sanitized.length ? sanitized[sanitized.length - 1] : 0;
        const text = String(ValueMath.toNumber(value));
        return idx === 0 ? text : text.padStart(3, '0');
      }).join('.');
    }

    function formatWithSuffix(value){
      const numeric = ValueMath.toNumber(value);
      const negative = ValueMath.compare(numeric, 0) < 0;
      const absVal = ValueMath.abs(numeric);
      const groups = splitIntoGroups(absVal);
      const { exponent } = ValueMath.toMantissaExponent(absVal, 1000);
      let formatted;
      if (exponent >= 2){
        const rawIndex = exponent - 1;
        const cappedIndex = rawIndex >= SUFFIXES.length ? SUFFIXES.length - 1 : rawIndex;
        const suffix = SUFFIXES[cappedIndex] || '';
        const head = ValueMath.toNumber(groups[0] || 0);
        const next = ValueMath.toNumber(groups[1] || 0);
        formatted = `${head}.${String(next).padStart(3, '0')}${suffix}`;
      } else {
        formatted = joinGroups(groups);
      }
      return negative && !ValueMath.isZero(absVal) ? `-${formatted}` : formatted;
    }

    function formatNumber(value){
      const numeric = ValueMath.toNumber(value);
      if (!Number.isFinite(numeric)) return '0';
      return formatWithSuffix(numeric);
    }

    function escapeHtml(value){
      const str = value == null ? "" : String(value);
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
      return str.replace(/[&<>"']/g, ch => map[ch] || ch);
    }

    function getReviveRewardValue(index){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      if (idx < REVIVE_REWARDS.length){
        return Math.max(0, Math.floor(REVIVE_REWARDS[idx] || 0));
      }
      const lastValue = REVIVE_REWARDS.length
        ? Math.max(0, Math.floor(REVIVE_REWARDS[REVIVE_REWARDS.length - 1] || 0))
        : 0;
      const extra = Math.max(0, idx - (REVIVE_REWARDS.length - 1));
      const step = Math.max(0, REVIVE_EXTRA_REWARD_STEP);
      const value = ValueMath.add(lastValue, ValueMath.mul(extra, step));
      if (!Number.isFinite(value) || value > Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
      return Math.max(0, Math.floor(value));
    }

    function getReviveCostValue(index){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      let cost = REVIVE_BASE_COST;
      for (let i = 0; i < idx; i++){
        cost = ValueMath.mul(cost, REVIVE_COST_MULTIPLIER);
        if (!Number.isFinite(cost) || cost > Number.MAX_VALUE){
          return Number.MAX_VALUE;
        }
      }
      if (!Number.isFinite(cost)) return Number.MAX_VALUE;
      return Math.max(1, Math.floor(cost));
    }

    function getReviveTotalBonus(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      if (c <= 0) return 0;
      let total = 0;
      for (let i = 0; i < c; i++){
        total = ValueMath.add(total, getReviveRewardValue(i));
        if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
          return Number.MAX_SAFE_INTEGER;
        }
      }
      return Math.max(0, Math.floor(total));
    }

    function getReviveBaseStartValue(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      if (c <= 0) return { apc: 1, aps: 0 };
      const total = getReviveTotalBonus(c);
      if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
        return { apc: Number.MAX_SAFE_INTEGER, aps: Number.MAX_SAFE_INTEGER };
      }
      const base = Math.max(0, Math.floor(total));
      return { apc: Math.max(1, base), aps: Math.max(0, base) };
    }

    function getReviveShopIncrementValue(count = reviveCount){
      const c = Math.max(0, Math.floor(Number.isFinite(count) ? count : Number(count) || 0));
      let increment = Math.max(1, shopIncrementBase);
      const growth = Math.max(Number.EPSILON, shopIncrementGrowthFactor);
      for (let i = 0; i < c; i++){
        if (!Number.isFinite(increment) || increment > Number.MAX_SAFE_INTEGER / growth){
          return Number.MAX_SAFE_INTEGER;
        }
        increment = ValueMath.mul(increment, growth);
      }
      if (!Number.isFinite(increment)) return Number.MAX_SAFE_INTEGER;
      return Math.max(1, Math.floor(increment));
    }

    function getReviveTier(index = reviveCount){
      const idx = Math.max(0, Math.floor(Number.isFinite(index) ? index : Number(index) || 0));
      return {
        index: idx,
        cost: getReviveCostValue(idx),
        reward: getReviveRewardValue(idx)
      };
    }

    function scaledToPercent(value){
      return Math.floor((value * 100 + Math.floor(MULTIPLIER_SCALE / 2)) / MULTIPLIER_SCALE);
    }

    function chanceScaledToPercent(value){
      return Math.floor((value * 100 + Math.floor(CHANCE_SCALE / 2)) / CHANCE_SCALE);
    }
    function formatSessionDuration(ms){
      const totalSeconds = Math.max(0, Math.floor(ms / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function formatRuntimeDuration(ms){
      const totalMinutes = Math.max(0, Math.floor(ms / 60000));
      const totalHours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      if (totalHours >= 24){
        const days = Math.floor(totalHours / 24);
        const hours = totalHours % 24;
        return `${days} j ${hours} h ${minutes} min`;
      }
      return `${totalHours} h ${minutes} min`;
    }

    function formatMultiplier(value){
      if (!Number.isFinite(value) || value <= 0) return '×0';
      let precision = 2;
      if (value >= 1000) precision = 0;
      else if (value >= 10) precision = 1;
      return `×${value.toFixed(precision)}`;
    }

    function renderMultiplierList(target, items){
      if (!target) return;
      if (!Array.isArray(items) || items.length === 0){
        target.innerHTML = '<li class="multiplier-item"><span>Aucun bonus</span><strong>×1.00</strong></li>';
        return;
      }
      target.innerHTML = items.map(item => {
        const data = item || {};
        const label = data.label || '';
        const value = Number.isFinite(data.value) ? data.value : 1;
        return `<li class="multiplier-item"><span>${label}</span><strong>${formatMultiplier(value)}</strong></li>`;
      }).join("");
    }
    const normalizeWord = str => (str || "").trim().toLowerCase();

    function getConfettiPalette(){
      return CONFETTI_PALETTES[currentTheme] || CONFETTI_PALETTES.dark;
    }

    function getAtomCenter(){
      if (!atomIcon) return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      const rect = atomIcon.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    function spawnConfettiBurst(origin = getAtomCenter(), pieces = CONFETTI_COUNT){
      if (!confettiLayer) return;
      const palette = getConfettiPalette();
      for (let i = 0; i < pieces; i++){
        const piece = document.createElement('span');
        piece.className = 'confetti-piece';

        const baseColor = palette[Math.floor(Math.random() * palette.length)];
        const accentColor = palette[Math.floor(Math.random() * palette.length)];
        const useGradient = Math.random() > 0.6 && baseColor !== accentColor;
        const gradientAngle = Math.floor(Math.random() * 360);
        piece.style.background = useGradient ? `linear-gradient(${gradientAngle}deg, ${baseColor}, ${accentColor})` : baseColor;

        const width = 6 + Math.random() * 10;
        const height = width * (0.6 + Math.random() * 0.9);
        piece.style.width = `${width.toFixed(2)}px`;
        piece.style.height = `${height.toFixed(2)}px`;
        piece.style.boxShadow = `0 0 8px ${baseColor}44`;

        const shapeRoll = Math.random();
        if (shapeRoll < 0.3){
          piece.style.borderRadius = `${Math.floor(Math.random() * 50)}%`;
        } else if (shapeRoll < 0.55){
          piece.style.borderRadius = '999px';
        } else if (shapeRoll < 0.8){
          piece.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
        } else {
          piece.style.clipPath = 'polygon(0% 0%, 80% 10%, 100% 100%, 20% 90%)';
        }

        const left = origin.x - width / 2;
        const top = origin.y - height / 2;
        piece.style.left = `${left}px`;
        piece.style.top = `${top}px`;

        confettiLayer.appendChild(piece);

        const angle = Math.random() * Math.PI * 2;
        const distance = 120 + Math.random() * 160;
        const driftX = Math.cos(angle) * distance;
        const driftY = Math.sin(angle) * distance + 80 + Math.random() * 80;
        const rotateStart = Math.random() * 360;
        const rotateDirection = Math.random() > 0.5 ? 1 : -1;
        const rotateEnd = rotateStart + rotateDirection * (360 + Math.random() * 540);
        const scaleEnd = 0.4 + Math.random() * 0.35;

        const animation = piece.animate([
          { transform: `translate3d(0,0,0) rotate(${rotateStart}deg) scale(1)`, opacity: 1 },
          { offset: 0.6, opacity: 1 },
          { transform: `translate3d(${driftX}px, ${driftY}px, 0) rotate(${rotateEnd}deg) scale(${scaleEnd})`, opacity: 0 }
        ], {
          duration: CONFETTI_LIFETIME,
          easing: 'cubic-bezier(0.32, 0.12, 0.17, 1)'
        });

        animation.onfinish = () => piece.remove();
        animation.oncancel = () => piece.remove();
      }
    }

    function getUnlockedAutoTrophiesCount(){
      return AUTO_GACHA_TROPHIES.reduce((count, trophy) => count + (trophies[trophy.key] ? 1 : 0), 0);
    }

    function hasAutoGachaUnlocked(){
      return getUnlockedAutoTrophiesCount() > 0;
    }

    function getAutoGachaInterval(){
      const unlocked = getUnlockedAutoTrophiesCount();
      if (unlocked <= 0) return null;
      const steps = Math.max(0, unlocked - 1);
      const maxSteps = Math.max(0, AUTO_GACHA_TROPHIES.length - 1);
      const effectiveSteps = Math.min(steps, maxSteps);
      const minInterval = Math.max(1, AUTO_GACHA_MIN_INTERVAL);
      const target = AUTO_GACHA_BASE_INTERVAL - effectiveSteps * AUTO_GACHA_INTERVAL_REDUCTION;
      return Math.max(minInterval, Math.max(1, target));
    }

    function formatAutoGachaCountdown(value){
      const totalSeconds = Math.max(0, Math.ceil(Number(value) || 0));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0){
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function resetAutoGachaCooldown(){
      const interval = getAutoGachaInterval();
      if (interval){
        if (autoGachaCooldown <= 0 || autoGachaCooldown > interval){
          autoGachaCooldown = interval;
        } else {
          autoGachaCooldown = Math.min(autoGachaCooldown, interval);
        }
      } else {
        autoGachaCooldown = 0;
      }
      updateAutoGachaHeader();
    }

    function updateAutoGachaHeader(){
      if (!autoGachaHeader) return;
      if (!hasAutoGachaUnlocked()){
        autoGachaHeader.textContent = "—";
        return;
      }
      autoGachaHeader.textContent = autoGachaCooldown <= 0
        ? "00:00"
        : formatAutoGachaCountdown(autoGachaCooldown);
    }

    function updateAutoGachaPanel(){
      if (!autoGachaPanel) return;
      const isMainActive = !!(mainPageEl && mainPageEl.classList.contains('active'));
      const shouldShow = hasAutoGachaUnlocked() && isMainActive;
      autoGachaPanel.classList.toggle('hidden', !shouldShow);
    }

    function showAutoGachaResult(result){
      lastAutoResult = result;
      if (autoGachaName && result?.element){
        autoGachaName.textContent = `${result.element.name} (${result.element.symbol})`;
      }
      if (autoGachaResultEl){
        if (result?.isNew){
          setLootResultClass('is-new', autoGachaResultEl);
          autoGachaResultEl.textContent = 'Nouveau!';
        } else if (result?.lootRarity){
          setLootResultClass(`rarity-${result.lootRarity.key}`, autoGachaResultEl);
          autoGachaResultEl.textContent = `Isotopes ×${result.lootRarity.multiplier}`;
        } else {
          setLootResultClass(null, autoGachaResultEl);
          autoGachaResultEl.textContent = '—';
        }
      }
      updateAutoGachaPanel();
      updateAutoGachaHeader();
    }

    function checkTrophies({ silent = false } = {}){
      let unlocked = false;
      for (const trophy of AUTO_GACHA_TROPHIES){
        if (!trophies[trophy.key] && totalAtoms >= trophy.threshold){
          trophies[trophy.key] = Date.now();
          unlocked = true;
          if (!silent) spawnConfettiBurst();
        }
      }
      if (unlocked){
        resetAutoGachaCooldown();
        updateAutoGachaHeader();
        updateAutoGachaPanel();
        refreshBonusList();
      }
      return unlocked;
    }

    function performAutoGachaRoll(){
      const result = rollGacha({ free:true, origin:"auto" });
      if (!result) return false;
      saveAndUpdate();
      showAutoGachaResult(result);
      return true;
    }

    function handleAutoGachaTick(deltaSeconds = 1){
      const interval = getAutoGachaInterval();
      if (!interval){
        autoGachaCooldown = 0;
        updateAutoGachaHeader();
        return;
      }
      if (!(mainPageEl && mainPageEl.classList.contains('active'))) return;
      autoGachaCooldown = Math.max(0, autoGachaCooldown - deltaSeconds);
      updateAutoGachaHeader();
      if (autoGachaCooldown > 0) return;
      if (!performAutoGachaRoll()){
        // Si le tirage échoue, on retente après un intervalle complet.
      }
      autoGachaCooldown = interval;
      updateAutoGachaHeader();
    }

    function pruneApcFrenzyEffects(now = Date.now()){
      apcFrenzyEffects = apcFrenzyEffects.filter(effect => effect.expiresAt > now);
    }

    function pruneApsFrenzyEffects(now = Date.now()){
      apsFrenzyEffects = apsFrenzyEffects.filter(effect => effect.expiresAt > now);
    }

    function getActiveApcFrenzyMultiplier(){
      pruneApcFrenzyEffects();
      if (!apcFrenzyEffects.length) return 1;
      return apcFrenzyEffects.reduce((mul, effect) => mul * effect.multiplier, 1);
    }

    function getActiveApsFrenzyMultiplier(){
      pruneApsFrenzyEffects();
      if (!apsFrenzyEffects.length) return 1;
      return apsFrenzyEffects.reduce((mul, effect) => mul * effect.multiplier, 1);
    }

    function getApcFrenzyStackCount(){
      pruneApcFrenzyEffects();
      return apcFrenzyEffects.length;
    }

    function getApsFrenzyStackCount(){
      pruneApsFrenzyEffects();
      return apsFrenzyEffects.length;
    }

    function getLongestApcFrenzyRemaining(){
      pruneApcFrenzyEffects();
      if (!apcFrenzyEffects.length) return 0;
      const now = Date.now();
      return Math.max(...apcFrenzyEffects.map(effect => Math.max(0, effect.expiresAt - now)));
    }

    function getLongestApsFrenzyRemaining(){
      pruneApsFrenzyEffects();
      if (!apsFrenzyEffects.length) return 0;
      const now = Date.now();
      return Math.max(...apsFrenzyEffects.map(effect => Math.max(0, effect.expiresAt - now)));
    }

    function triggerApcFrenzyBonus(){
      const multiplier = Math.max(1, currentFrenzyMultiplierBase);
      const expiresAt = Date.now() + APC_FRENZY_DURATION_MS;
      apcFrenzyEffects.push({ multiplier, expiresAt });
      spawnConfettiBurst(getAtomCenter(), Math.max(12, Math.floor(CONFETTI_COUNT / 2)));
      updateUI();
    }

    function triggerApsFrenzyBonus(){
      const multiplier = Math.max(1, currentFrenzyMultiplierBase);
      const expiresAt = Date.now() + APS_FRENZY_DURATION_MS;
      apsFrenzyEffects.push({ multiplier, expiresAt });
      spawnConfettiBurst(getAtomCenter(), Math.max(12, Math.floor(CONFETTI_COUNT / 2)));
      updateUI();
    }

    function hideApcFrenzyOrb(){
      if (apcFrenzyOrbTimeout){
        clearTimeout(apcFrenzyOrbTimeout);
        apcFrenzyOrbTimeout = null;
      }
      if (apcFrenzyOrbEl){
        apcFrenzyOrbEl.classList.remove('visible');
        apcFrenzyOrbEl.disabled = true;
        if (document.activeElement === apcFrenzyOrbEl) apcFrenzyOrbEl.blur();
      }
      apcFrenzyOrbVisible = false;
    }

    function hideApsFrenzyOrb(){
      if (apsFrenzyOrbTimeout){
        clearTimeout(apsFrenzyOrbTimeout);
        apsFrenzyOrbTimeout = null;
      }
      if (apsFrenzyOrbEl){
        apsFrenzyOrbEl.classList.remove('visible');
        apsFrenzyOrbEl.disabled = true;
        if (document.activeElement === apsFrenzyOrbEl) apsFrenzyOrbEl.blur();
      }
      apsFrenzyOrbVisible = false;
    }

    function spawnApcFrenzyOrb(){
      if (!apcFrenzyOrbEl || apcFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      const mainRect = mainPageEl.getBoundingClientRect();
      const atomRect = atomIcon ? atomIcon.getBoundingClientRect() : null;
      if (!atomRect) return;
      const centerX = atomRect.left + atomRect.width / 2 - mainRect.left;
      const centerY = atomRect.top + atomRect.height / 2 - mainRect.top;
      const radius = atomRect.width * (0.6 + Math.random() * 0.5);
      const angle = Math.random() * Math.PI * 2;
      let targetX = centerX + Math.cos(angle) * radius;
      let targetY = centerY + Math.sin(angle) * radius;
      const halfWidth = atomRect.width / 2;
      const halfHeight = atomRect.height / 2;
      const marginX = Math.max(halfWidth, Math.max(24, atomRect.width * 0.3));
      const marginY = Math.max(halfHeight, Math.max(24, atomRect.height * 0.3));
      targetX = Math.min(Math.max(targetX, marginX), Math.max(marginX, mainRect.width - marginX));
      targetY = Math.min(Math.max(targetY, marginY), Math.max(marginY, mainRect.height - marginY));
      apcFrenzyOrbEl.style.left = `${targetX}px`;
      apcFrenzyOrbEl.style.top = `${targetY}px`;
      apcFrenzyOrbEl.classList.add('visible');
      apcFrenzyOrbEl.disabled = false;
      apcFrenzyOrbVisible = true;
      if (apcFrenzyOrbTimeout) clearTimeout(apcFrenzyOrbTimeout);
      apcFrenzyOrbTimeout = setTimeout(()=> hideApcFrenzyOrb(), FRENZY_ORB_LIFETIME_MS);
    }

    function spawnApsFrenzyOrb(){
      if (!apsFrenzyOrbEl || apsFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      const mainRect = mainPageEl.getBoundingClientRect();
      const atomRect = atomIcon ? atomIcon.getBoundingClientRect() : null;
      if (!atomRect) return;
      const centerX = atomRect.left + atomRect.width / 2 - mainRect.left;
      const centerY = atomRect.top + atomRect.height / 2 - mainRect.top;
      const radius = atomRect.width * (0.6 + Math.random() * 0.5);
      const angle = Math.random() * Math.PI * 2;
      let targetX = centerX + Math.cos(angle) * radius;
      let targetY = centerY + Math.sin(angle) * radius;
      const halfWidth = atomRect.width / 2;
      const halfHeight = atomRect.height / 2;
      const marginX = Math.max(halfWidth, Math.max(24, atomRect.width * 0.3));
      const marginY = Math.max(halfHeight, Math.max(24, atomRect.height * 0.3));
      targetX = Math.min(Math.max(targetX, marginX), Math.max(marginX, mainRect.width - marginX));
      targetY = Math.min(Math.max(targetY, marginY), Math.max(marginY, mainRect.height - marginY));
      apsFrenzyOrbEl.style.left = `${targetX}px`;
      apsFrenzyOrbEl.style.top = `${targetY}px`;
      apsFrenzyOrbEl.classList.add('visible');
      apsFrenzyOrbEl.disabled = false;
      apsFrenzyOrbVisible = true;
      if (apsFrenzyOrbTimeout) clearTimeout(apsFrenzyOrbTimeout);
      apsFrenzyOrbTimeout = setTimeout(()=> hideApsFrenzyOrb(), FRENZY_ORB_LIFETIME_MS);
    }

    function checkApcFrenzySpawn(){
      if (apcFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      if (Math.floor(Math.random() * FRENZY_SPAWN_DENOM) === 0) spawnApcFrenzyOrb();
    }

    function checkApsFrenzySpawn(){
      if (apsFrenzyOrbVisible) return;
      if (!mainPageEl || !mainPageEl.classList.contains('active')) return;
      if (Math.floor(Math.random() * FRENZY_SPAWN_DENOM) === 0) spawnApsFrenzyOrb();
    }

    function rollLootRarity(){
      const totalWeight = LOOT_RARITIES.reduce((sum, rarity)=> sum + (rarity.weight || 0), 0);
      if (totalWeight <= 0) return LOOT_RARITIES[0];
      let roll = Math.floor(Math.random() * totalWeight);
      let acc = 0;
      for (const rarity of LOOT_RARITIES){
        acc += rarity.weight || 0;
        if (roll < acc) return rarity;
      }
      return LOOT_RARITIES[LOOT_RARITIES.length - 1];
    }

    function getIsoStock(symbol){
      return Math.max(0, Math.floor((gacha.isoStock && gacha.isoStock[symbol]) || 0));
    }

    function computeTotalIsotopes(){
      return Object.values(gacha.isoStock || {}).reduce((sum, val)=> sum + Math.max(0, Math.floor(val||0)), 0);
    }

    function syncTotalIsotopes(){
      gacha.isotopes = computeTotalIsotopes();
    }

    function addIsotopes(symbol, amount){
      if (!amount) return;
      const current = getIsoStock(symbol);
      gacha.isoStock[symbol] = current + Math.max(0, Math.floor(amount));
      syncTotalIsotopes();
    }

    function spendIsotopes(symbol, amount){
      const cost = Math.max(0, Math.floor(amount));
      if (cost === 0) return true;
      const current = getIsoStock(symbol);
      if (current < cost) return false;
      const remaining = current - cost;
      if (remaining > 0) gacha.isoStock[symbol] = remaining; else delete gacha.isoStock[symbol];
      syncTotalIsotopes();
      return true;
    }

    function getMoleculeState(){
      if (!gacha.molecules || typeof gacha.molecules !== "object"){
        gacha.molecules = createDefaultMoleculeProgress();
      }
      return gacha.molecules;
    }

    function getMoleculeDust(){
      const state = getMoleculeState();
      return Math.max(0, Math.floor(state.dust || 0));
    }

    function addMoleculeDust(amount){
      const inc = Math.max(0, Math.floor(amount));
      if (!inc) return;
      const state = getMoleculeState();
      state.dust = Math.max(0, Math.floor(state.dust || 0) + inc);
    }

    function getMoleculePityScaled(tier){
      const state = getMoleculeState();
      if (!state.pityScaled || typeof state.pityScaled !== "object") state.pityScaled = {};
      return Math.max(0, Math.floor(state.pityScaled[tier] || 0));
    }

    function setMoleculePityScaled(tier, value){
      const state = getMoleculeState();
      if (!state.pityScaled || typeof state.pityScaled !== "object") state.pityScaled = {};
      state.pityScaled[tier] = Math.max(0, Math.min(Math.floor(value || 0), CHANCE_SCALE));
    }

    function getMoleculeLastResult(){
      const state = getMoleculeState();
      if (!state.lastResult || typeof state.lastResult !== "object") return null;
      return state.lastResult;
    }

    function setMoleculeLastResult(result){
      const state = getMoleculeState();
      if (!result){
        state.lastResult = null;
        return;
      }
      state.lastResult = {
        key: sanitizeString(result.key, ""),
        success: !!result.success,
        message: sanitizeString(result.message, ""),
        timestamp: Math.max(0, Math.floor(result.timestamp || Date.now()))
      };
    }

    function isMoleculeUnlocked(key){
      const state = getMoleculeState();
      if (!state.unlocked || typeof state.unlocked !== "object") state.unlocked = {};
      return !!state.unlocked[key];
    }

    function unlockMolecule(key){
      const state = getMoleculeState();
      if (!state.unlocked || typeof state.unlocked !== "object") state.unlocked = {};
      state.unlocked[key] = true;
    }

    function getUnlockedMolecules(){
      const state = getMoleculeState();
      if (!state.unlocked || typeof state.unlocked !== "object") return [];
      const keys = Object.keys(state.unlocked).filter(key => state.unlocked[key] && MOLECULE_BY_KEY[key]);
      return keys.map(key => MOLECULE_BY_KEY[key]);
    }

    function getFamiliesForTier(tier){
      return (MOLECULE_RARITY_FAMILY_GROUPS[tier] || []).slice();
    }

    function getAvailableIsotopesForFamilies(families){
      const familySet = new Set((families || []).filter(Boolean));
      let total = 0;
      const stocks = [];
      if (!familySet.size) return { total: 0, stocks };
      for (const [symbol, qty] of Object.entries(gacha.isoStock || {})){
        const amount = Math.max(0, Math.floor(qty || 0));
        if (!amount) continue;
        const element = ELEMENT_BY_SYMBOL[symbol];
        if (!element || !familySet.has(element.family)) continue;
        total = ValueMath.add(total, amount);
        stocks.push({ symbol, amount });
      }
      return { total, stocks };
    }

    function planIsotopeConsumption(families, amount){
      const target = Math.max(0, Math.floor(amount));
      if (target <= 0) return {};
      const { stocks } = getAvailableIsotopesForFamilies(families);
      if (!stocks.length) return null;
      const pool = stocks.map(entry => ({ symbol: entry.symbol, count: entry.amount }));
      const consumed = {};
      let remaining = target;
      while (remaining > 0){
        const total = pool.reduce((sum, entry) => sum + entry.count, 0);
        if (total <= 0) return null;
        let roll = Math.floor(Math.random() * total);
        let chosenIndex = 0;
        for (let i = 0; i < pool.length; i++){
          const entry = pool[i];
          if (roll < entry.count){
            chosenIndex = i;
            break;
          }
          roll -= entry.count;
        }
        const entry = pool[chosenIndex];
        entry.count -= 1;
        consumed[entry.symbol] = (consumed[entry.symbol] || 0) + 1;
        if (entry.count <= 0) pool.splice(chosenIndex, 1);
        remaining -= 1;
      }
      return consumed;
    }

    function spendIsotopesFromFamilies(families, amount){
      const consumption = planIsotopeConsumption(families, amount);
      if (!consumption) return null;
      for (const [symbol, spent] of Object.entries(consumption)){
        const cost = Math.max(0, Math.floor(spent));
        if (!cost) continue;
        const current = getIsoStock(symbol);
        if (current < cost) return null;
        const remaining = current - cost;
        if (remaining > 0) gacha.isoStock[symbol] = remaining; else delete gacha.isoStock[symbol];
      }
      syncTotalIsotopes();
      return consumption;
    }

    function refundIsotopesFromConsumption(consumption, amount){
      const refundable = Math.max(0, Math.floor(amount));
      if (!consumption || !refundable) return 0;
      const entries = Object.entries(consumption)
        .map(([symbol, count]) => ({ symbol, count: Math.max(0, Math.floor(count)) }))
        .filter(entry => entry.count > 0);
      if (!entries.length) return 0;
      let remaining = refundable;
      let refunded = 0;
      while (remaining > 0){
        const total = entries.reduce((sum, entry) => sum + entry.count, 0);
        if (total <= 0) break;
        let roll = Math.floor(Math.random() * total);
        for (const entry of entries){
          if (entry.count <= 0) continue;
          if (roll < entry.count){
            gacha.isoStock[entry.symbol] = getIsoStock(entry.symbol) + 1;
            entry.count -= 1;
            remaining -= 1;
            refunded += 1;
            break;
          }
          roll -= entry.count;
        }
      }
      if (refunded > 0) syncTotalIsotopes();
      return refunded;
    }

    function hasFullTable(){
      for (const el of ELEMENTS){
        if (!gacha.owned[el.symbol]) return false;
      }
      return true;
    }

    function isMoleculeStationUnlocked(){
      if (MOLECULE_UNLOCK.requiredRevives > 0 && reviveCount < MOLECULE_UNLOCK.requiredRevives) return false;
      if (MOLECULE_UNLOCK.requiresFullTable && !hasFullTable()) return false;
      return true;
    }

    function getMoleculeUnlockMessage(){
      if (isMoleculeStationUnlocked()) return "";
      const parts = [];
      if (MOLECULE_UNLOCK.requiredRevives > 0 && reviveCount < MOLECULE_UNLOCK.requiredRevives){
        parts.push(`Réalise ${formatNumber(MOLECULE_UNLOCK.requiredRevives)} renaissances.`);
      }
      if (MOLECULE_UNLOCK.requiresFullTable && !hasFullTable()){
        parts.push("Complète le tableau périodique (découvre tous les éléments).");
      }
      if (parts.length === 0) return "La station de synthèse est verrouillée.";
      return `La station de synthèse est verrouillée. ${parts.join(' ')}`;
    }

    function getActiveMoleculeFusionBonuses(){
      const effects = computeMoleculeEffects();
      return {
        pityBonusPerFailPercentScaled: Math.max(0, Math.floor(effects.pityBonusPerFailPercentScaled || 0)),
        pityMaxPercentScaled: Math.max(0, Math.floor(effects.pityMaxPercentScaled || 0)),
        refundOnFailPercentScaled: Math.max(0, Math.floor(effects.refundOnFailPercentScaled || 0))
      };
    }

    function evaluateMoleculeAvailability(molecule){
      if (!molecule) return { canAttempt:false, reason:"Molécule inconnue." };
      if (!isMoleculeStationUnlocked()){
        return { canAttempt:false, reason: getMoleculeUnlockMessage() || "Station de synthèse verrouillée." };
      }
      if (isMoleculeUnlocked(molecule.key)){
        return { canAttempt:false, reason: `${molecule.formula} est déjà synthétisée.` };
      }
      const requirements = molecule.requirements || {};
      if (requirements.awakenLevel && getTotalAwakenCount() < requirements.awakenLevel){
        return { canAttempt:false, reason: `Requiert ${formatNumber(requirements.awakenLevel)} éveils.` };
      }
      if (Array.isArray(requirements.familiesComplete)){
        for (const familyKey of requirements.familiesComplete){
          if (!isFamilySetComplete(familyKey)){
            const label = FAMILIES[familyKey]?.label || familyKey;
            return { canAttempt:false, reason: `Complète le set ${label}.` };
          }
        }
      }
      const families = getFamiliesForTier(molecule.tier);
      if (!families.length){
        return { canAttempt:false, reason: "Rareté indisponible pour le moment." };
      }
      const { total } = getAvailableIsotopesForFamilies(families);
      if (total < molecule.costIso){
        return { canAttempt:false, reason: `Isotopes insuffisants (${formatNumber(total)} / ${formatNumber(molecule.costIso)}).` };
      }
      return { canAttempt:true, reason:"" };
    }

    function attemptMoleculeFusion(key){
      const molecule = MOLECULE_BY_KEY[key];
      if (!molecule){
        return { attempted:false, success:false, message:"Molécule inconnue." };
      }
      if (!isMoleculeStationUnlocked()){
        return { attempted:false, success:false, message: getMoleculeUnlockMessage() || "Station de synthèse verrouillée." };
      }
      if (isMoleculeUnlocked(key)){
        return { attempted:false, success:false, message: `${molecule.formula} est déjà synthétisée.` };
      }
      const availability = evaluateMoleculeAvailability(molecule);
      if (!availability.canAttempt){
        return { attempted:false, success:false, message: availability.reason || "Conditions non remplies." };
      }
      const families = getFamiliesForTier(molecule.tier);
      const consumption = spendIsotopesFromFamilies(families, molecule.costIso);
      if (!consumption){
        return { attempted:false, success:false, message: "Pas assez d'isotopes dans ce groupe." };
      }
      const totalSpent = Object.values(consumption).reduce((sum, value) => sum + Math.max(0, Math.floor(value)), 0);
      const pityBefore = getMoleculePityScaled(molecule.tier);
      const baseChance = Math.max(0, Math.min(CHANCE_SCALE, Math.floor(molecule.successChanceScaled || 0)));
      const totalChance = Math.min(CHANCE_SCALE, baseChance + pityBefore);
      const roll = Math.floor(Math.random() * CHANCE_SCALE);
      const success = roll < totalChance;
      const chancePercent = chanceScaledToPercent(totalChance);
      let message = "";
      let refunded = 0;
      if (success){
        unlockMolecule(key);
        setMoleculePityScaled(molecule.tier, 0);
        message = `Fusion réussie : ${molecule.formula} activée (${chancePercent}% de réussite).`;
      } else {
        const bonuses = getActiveMoleculeFusionBonuses();
        const pityStep = Math.max(0, MOLECULE_PITY_STEP_SCALED + Math.max(0, Math.floor(bonuses.pityBonusPerFailPercentScaled || 0)));
        const pityCap = Math.max(0, Math.min(CHANCE_SCALE, MOLECULE_MAX_PITY_SCALED + Math.max(0, Math.floor(bonuses.pityMaxPercentScaled || 0))));
        const newPity = Math.min(pityCap, ValueMath.add(pityBefore, pityStep));
        setMoleculePityScaled(molecule.tier, newPity);
        const refundPercentScaled = Math.max(0, Math.min(MULTIPLIER_SCALE, Math.floor(bonuses.refundOnFailPercentScaled || 0)));
        if (refundPercentScaled > 0){
          refunded = Math.min(totalSpent, ValueMath.divScale(totalSpent, refundPercentScaled, MULTIPLIER_SCALE));
          if (refunded > 0) refundIsotopesFromConsumption(consumption, refunded);
        }
        const dustGain = Math.max(0, ValueMath.sub(totalSpent, refunded));
        if (dustGain > 0) addMoleculeDust(dustGain);
        const pityPercent = chanceScaledToPercent(getMoleculePityScaled(molecule.tier));
        const parts = [`Fusion ratée (${chancePercent}% de réussite).`, `Pitié : ${pityPercent}%.`];
        if (dustGain > 0) parts.push(`Poussière +${formatNumber(dustGain)}.`);
        if (refunded > 0) parts.push(`Remboursement ${formatNumber(refunded)} iso.`);
        message = parts.join(' ');
      }
      const result = { key, success, attempted:true, message, chancePercent, spent: totalSpent, refunded, timestamp: Date.now() };
      setMoleculeLastResult(result);
      return result;
    }

    function getAwakenLevel(symbol){
      return Math.min(AWAKEN_MAX, (gacha.awakens && gacha.awakens[symbol]) || 0);
    }

    function setAwakenLevel(symbol, level){
      gacha.awakens[symbol] = Math.min(AWAKEN_MAX, Math.max(0, Math.floor(level)));
    }

    function getAwakenMultiplier(level){
      const clampedLevel = Math.max(0, Math.min(level, AWAKEN_MAX));
      return Math.pow(AWAKEN_MULTIPLIER_BASE, clampedLevel);
    }

    function getAwakenCost(level){
      return AWAKEN_COSTS[level] ?? null;
    }

    function getTotalAwakenCount(){
      return toNonNegativeInt(gacha.awakenCount || 0);
    }

    function registerAwakenProgress(amount = 1){
      const increment = Math.max(0, Math.floor(amount));
      if (!increment) return;
      const current = getTotalAwakenCount();
      const next = ValueMath.add(current, increment);
      gacha.awakenCount = next >= Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : next;
    }

    function getAwakenDiscountSteps(){
      if (AWAKEN_DISCOUNT_STEP <= 0) return 0;
      const total = getTotalAwakenCount();
      return Math.floor(total / AWAKEN_DISCOUNT_STEP);
    }

    function getAwakenDiscountScaled(){
      const steps = getAwakenDiscountSteps();
      if (steps <= 0) return 0;
      const ratioBase = Math.min(Math.max(AWAKEN_DISCOUNT_RATIO, 0), 1);
      if (ratioBase <= 0) return MULTIPLIER_SCALE - 1;
      if (ratioBase >= 1) return 0;
      const ratio = Math.pow(ratioBase, steps);
      const ratioScaled = Math.max(1, Math.ceil(MULTIPLIER_SCALE * ratio));
      const discount = MULTIPLIER_SCALE - ratioScaled;
      return Math.max(0, Math.min(discount, MULTIPLIER_SCALE - 1));
    }

    function getDiscountedAwakenCost(level, isoDiscountScaled){
      const baseCost = getAwakenCost(level);
      if (baseCost == null) return null;
      if (baseCost === 0) return 0;
      const discount = Math.max(0, Math.min(isoDiscountScaled || 0, MULTIPLIER_SCALE));
      const adjustedBase = ValueMath.mul(ValueMath.sub(MULTIPLIER_SCALE, discount), baseCost);
      const numerator = ValueMath.add(adjustedBase, ValueMath.sub(MULTIPLIER_SCALE, 1));
      return Math.max(1, ValueMath.divScale(numerator, 1, MULTIPLIER_SCALE));
    }

    function getOwnedElementCount(){
      if (!gacha.owned) return 0;
      let count = 0;
      for (const symbol of ORDERED_SYMBOLS){
        if (gacha.owned[symbol]) count++;
      }
      return count;
    }

    function hasFullCollection(){
      return getOwnedElementCount() >= ORDERED_SYMBOLS.length;
    }

    function canAnyAwaken(discount = currentIsoDiscount){
      if (!gacha.owned) return false;
      for (const symbol of ORDERED_SYMBOLS){
        if (!gacha.owned[symbol]) continue;
        const level = getAwakenLevel(symbol);
        if (level >= AWAKEN_MAX) continue;
        const cost = getDiscountedAwakenCost(level, discount);
        if (cost == null) continue;
        if (getIsoStock(symbol) >= cost) return true;
      }
      return false;
    }

    function updateAwakenWrapperVisibility(){
      if (!awakenWrapper) return;
      const singleVisible = awakenBtn && !awakenBtn.classList.contains("hidden");
      const allVisible = awakenAllBtn && !awakenAllBtn.classList.contains("hidden");
      const shouldShow = singleVisible || allVisible;
      awakenWrapper.classList.toggle("hidden", !shouldShow);
    }

    function updateAwakenAllButton(){
      if (!awakenAllBtn) return;
      const fullCollection = hasFullCollection();
      if (!fullCollection){
        awakenAllBtn.classList.add("hidden");
        awakenAllBtn.disabled = true;
        awakenAllBtn.removeAttribute("title");
        if (awakenAllCard) awakenAllCard.classList.add("hidden");
        updateAwakenWrapperVisibility();
        return;
      }
      awakenAllBtn.classList.remove("hidden");
      if (awakenAllCard) awakenAllCard.classList.remove("hidden");
      const hasUpgrade = canAnyAwaken();
      awakenAllBtn.disabled = !hasUpgrade;
      if (!hasUpgrade){
        awakenAllBtn.title = "Pas assez d'isotopes pour éveiller d'autres éléments.";
      } else {
        awakenAllBtn.removeAttribute("title");
      }
      updateAwakenWrapperVisibility();
    }

    // Probabilités familiales (pondérées)
    function pickFamily(){
      const entries = Object.entries(FAMILIES).filter(([k,v]) => (v.weight || 0) > 0);
      if (!entries.length) return null;
      const sum = entries.reduce((s,[,v])=> s + (v.weight || 0), 0);
      if (sum <= 0) return entries[0][0];
      let roll = Math.floor(Math.random() * sum);
      let acc = 0;
      for (const [key, v] of entries){
        acc += v.weight || 0;
        if (roll < acc) return key;
      }
      return entries[0][0];
    }

    function animateAtom(isCrit = false){
      playPopSound();
      if (!atomIcon){
        if (isCrit){
          playCritSound();
          spawnConfettiBurst();
        }
        return;
      }
      atomIcon.classList.add("enflé");
      atomIcon.classList.add("colorShift");
      setTimeout(()=>{
        atomIcon.classList.remove("enflé");
        atomIcon.classList.remove("colorShift");
      }, 220);
      if (isCrit){
        playCritSound();
        atomIcon.classList.add("crit");
        spawnConfettiBurst();
        if (critFlashTimeout) clearTimeout(critFlashTimeout);
        critFlashTimeout = setTimeout(()=>{
          atomIcon.classList.remove("crit");
          critFlashTimeout = null;
        }, 650);
      }
    }

    function saveAndUpdate(){ saveAll(); updateUI(); }

    /* ===================== Bonus de familles ===================== */
    function computeMoleculeEffects(){
      const effects = {};
      const state = getMoleculeState();
      if (!state.unlocked || typeof state.unlocked !== "object") return effects;
      for (const [key, active] of Object.entries(state.unlocked)){
        if (!active) continue;
        const molecule = MOLECULE_BY_KEY[key];
        if (!molecule) continue;
        const details = molecule.effectDetails || {};
        for (const [effectKey, value] of Object.entries(details)){
          const numeric = Math.floor(Number(value) || 0);
          if (!Number.isFinite(numeric)) continue;
          effects[effectKey] = (effects[effectKey] || 0) + numeric;
        }
      }
      return effects;
    }

    function computeFamilyEffects(){
      const perFamCount = {};
      const perFamWeight = {};
      for (const key of Object.keys(FAMILIES)){
        perFamCount[key] = 0;
        perFamWeight[key] = 0;
      }
      for (const el of ELEMENTS){
        if (!gacha.owned[el.symbol]) continue;
        const lvl = getAwakenLevel(el.symbol);
        const weight = getAwakenMultiplier(lvl);
        const familyKey = el.family;
        perFamCount[familyKey] = (perFamCount[familyKey] || 0) + 1;
        perFamWeight[familyKey] = (perFamWeight[familyKey] || 0) + weight;
      }

      let critUnits = 0;
      let apcMul = MULTIPLIER_SCALE;
      let apsMul = MULTIPLIER_SCALE;
      let inflRed = 0;
      let offlineBonus = 0;
      let globalMul = MULTIPLIER_SCALE;
      let isoDiscount = getAwakenDiscountScaled();
      let apcFlat = 0;
      let apsFlat = 0;
      let hybridAPC = 0;
      let hybridAPS = 0;
      let frenzyBase = Math.max(1, FRENZY_BASE_MULTIPLIER);
      let frenzyChargeBonus = 0;
      let frenzyChargePercentScaled = 0;
      let frenzySpawnBonusPercentScaled = 0;
      let extraFrenzyDurationMs = 0;
      let refundOnFailPercentScaled = 0;
      let pityBonusPerFailPercentScaled = 0;
      let pityMaxPercentScaled = 0;
      let critChanceBonusScaled = 0;
      let critDamageBonusFlat = 0;

      for (const [familyKey, weight] of Object.entries(perFamWeight)){
        if (!weight) continue;
        const perWeight = FAMILY_EFFECTS[familyKey]?.perWeight || {};
        if (perWeight.critUnits) critUnits = ValueMath.add(critUnits, ValueMath.mul(weight, perWeight.critUnits));
        if (perWeight.apcPercentScaled) apcMul = ValueMath.add(apcMul, ValueMath.mul(weight, perWeight.apcPercentScaled));
        if (perWeight.apsPercentScaled) apsMul = ValueMath.add(apsMul, ValueMath.mul(weight, perWeight.apsPercentScaled));
        if (perWeight.apcFlat) apcFlat = ValueMath.add(apcFlat, ValueMath.mul(weight, perWeight.apcFlat));
        if (perWeight.apsFlat) apsFlat = ValueMath.add(apsFlat, ValueMath.mul(weight, perWeight.apsFlat));
        if (perWeight.offlinePercentScaled) offlineBonus = ValueMath.add(offlineBonus, ValueMath.mul(weight, perWeight.offlinePercentScaled));
        if (perWeight.globalPercentScaled) globalMul = ValueMath.add(globalMul, ValueMath.mul(weight, perWeight.globalPercentScaled));
        if (perWeight.hybridApcScaled) hybridAPC = ValueMath.add(hybridAPC, ValueMath.mul(weight, perWeight.hybridApcScaled));
        if (perWeight.hybridApsScaled) hybridAPS = ValueMath.add(hybridAPS, ValueMath.mul(weight, perWeight.hybridApsScaled));
        if (perWeight.inflationReductionScaled) inflRed = ValueMath.add(inflRed, ValueMath.mul(weight, perWeight.inflationReductionScaled));
        if (perWeight.frenzyBaseIncrement) frenzyBase = ValueMath.add(frenzyBase, ValueMath.mul(weight, perWeight.frenzyBaseIncrement));
      }

      const isSet = familyKey => (perFamCount[familyKey] || 0) === (FAMILY_SET_SIZES[familyKey] || 0);
      for (const familyKey of Object.keys(FAMILIES)){
        if (!isSet(familyKey)) continue;
        const setBonus = FAMILY_EFFECTS[familyKey]?.setBonus || {};
        if (setBonus.critUnits) critUnits = ValueMath.add(critUnits, setBonus.critUnits);
        if (setBonus.apcPercentScaled) apcMul = ValueMath.add(apcMul, setBonus.apcPercentScaled);
        if (setBonus.apsPercentScaled) apsMul = ValueMath.add(apsMul, setBonus.apsPercentScaled);
        if (setBonus.apcFlat) apcFlat = ValueMath.add(apcFlat, setBonus.apcFlat);
        if (setBonus.apsFlat) apsFlat = ValueMath.add(apsFlat, setBonus.apsFlat);
        if (setBonus.offlinePercentScaled) offlineBonus = ValueMath.add(offlineBonus, setBonus.offlinePercentScaled);
        if (setBonus.globalPercentScaled) globalMul = ValueMath.add(globalMul, setBonus.globalPercentScaled);
        if (setBonus.hybridApcScaled) hybridAPC = ValueMath.add(hybridAPC, setBonus.hybridApcScaled);
        if (setBonus.hybridApsScaled) hybridAPS = ValueMath.add(hybridAPS, setBonus.hybridApsScaled);
        if (setBonus.inflationReductionScaled) inflRed = ValueMath.add(inflRed, setBonus.inflationReductionScaled);
        if (setBonus.frenzyBaseIncrement) frenzyBase = ValueMath.add(frenzyBase, setBonus.frenzyBaseIncrement);
        if (setBonus.apcMultiplierScale) apcMul = ValueMath.divScale(apcMul, setBonus.apcMultiplierScale, MULTIPLIER_SCALE);
        if (setBonus.apsMultiplierScale) apsMul = ValueMath.divScale(apsMul, setBonus.apsMultiplierScale, MULTIPLIER_SCALE);
        if (setBonus.globalMultiplierScale) globalMul = ValueMath.divScale(globalMul, setBonus.globalMultiplierScale, MULTIPLIER_SCALE);
      }

      const moleculeEffects = computeMoleculeEffects();
      if (moleculeEffects.apcPercentScaled) apcMul = ValueMath.add(apcMul, moleculeEffects.apcPercentScaled);
      if (moleculeEffects.apsPercentScaled) apsMul = ValueMath.add(apsMul, moleculeEffects.apsPercentScaled);
      if (moleculeEffects.apcFlat) apcFlat = ValueMath.add(apcFlat, moleculeEffects.apcFlat);
      if (moleculeEffects.apsFlat) apsFlat = ValueMath.add(apsFlat, moleculeEffects.apsFlat);
      if (moleculeEffects.offlinePercentScaled) offlineBonus = ValueMath.add(offlineBonus, moleculeEffects.offlinePercentScaled);
      if (moleculeEffects.globalPercentScaled) globalMul = ValueMath.add(globalMul, moleculeEffects.globalPercentScaled);
      if (moleculeEffects.inflationReductionScaled) inflRed = ValueMath.add(inflRed, moleculeEffects.inflationReductionScaled);
      if (moleculeEffects.critChanceBonusScaled) critChanceBonusScaled = ValueMath.add(critChanceBonusScaled, moleculeEffects.critChanceBonusScaled);
      if (moleculeEffects.critDamageBonusPercent) critDamageBonusFlat = ValueMath.add(critDamageBonusFlat, moleculeEffects.critDamageBonusPercent);
      if (moleculeEffects.frenzyChargeBonus) frenzyChargeBonus = ValueMath.add(frenzyChargeBonus, moleculeEffects.frenzyChargeBonus);
      if (moleculeEffects.frenzyChargeBonusPercentScaled) frenzyChargePercentScaled = ValueMath.add(frenzyChargePercentScaled, moleculeEffects.frenzyChargeBonusPercentScaled);
      if (moleculeEffects.frenzySpawnBonusPercentScaled) frenzySpawnBonusPercentScaled = ValueMath.add(frenzySpawnBonusPercentScaled, moleculeEffects.frenzySpawnBonusPercentScaled);
      if (moleculeEffects.extraFrenzyDurationMs) extraFrenzyDurationMs = ValueMath.add(extraFrenzyDurationMs, moleculeEffects.extraFrenzyDurationMs);
      if (moleculeEffects.refundOnFailPercentScaled) refundOnFailPercentScaled = ValueMath.add(refundOnFailPercentScaled, moleculeEffects.refundOnFailPercentScaled);
      if (moleculeEffects.pityBonusPerFailPercentScaled) pityBonusPerFailPercentScaled = ValueMath.add(pityBonusPerFailPercentScaled, moleculeEffects.pityBonusPerFailPercentScaled);
      if (moleculeEffects.pityMaxPercentScaled) pityMaxPercentScaled = ValueMath.add(pityMaxPercentScaled, moleculeEffects.pityMaxPercentScaled);

      inflRed = Math.min(inflRed, GACHA_DISCOUNT_CAP_SCALED);

      const chancePerUnit = Math.max(0, CRIT_SETTINGS.chancePerUnitScaled);
      const maxChance = Math.max(0, CRIT_SETTINGS.maxChanceScaled);
      const critChance = Math.min(maxChance, ValueMath.mul(critUnits, chancePerUnit));
      const thresholdUnits = Math.max(0, CRIT_SETTINGS.damageThresholdUnits);
      const extraCritUnits = Math.max(0, ValueMath.sub(critUnits, thresholdUnits));
      const critChanceWithBonus = Math.min(maxChance, ValueMath.add(critChance, Math.max(0, critChanceBonusScaled)));
      const critDamagePercent = Math.max(0, ValueMath.add(
        ValueMath.add(CRIT_SETTINGS.baseCritDamagePercent, ValueMath.mul(extraCritUnits, CRIT_SETTINGS.extraDamagePerUnit)),
        Math.max(0, critDamageBonusFlat)
      ));

      return {
        critChance: critChanceWithBonus,
        critDamagePercent,
        apcMul,
        apsMul,
        apcFlat,
        apsFlat,
        inflRed,
        offlineBonus,
        globalMul,
        isoDiscount,
        hybridAPC,
        hybridAPS,
        frenzyBase,
        frenzyChargeBonus,
        frenzyChargePercentScaled,
        frenzySpawnBonusPercentScaled,
        extraFrenzyDurationMs,
        refundOnFailPercentScaled,
        pityBonusPerFailPercentScaled,
        pityMaxPercentScaled
      };
    }

    function applyMultiplier(value, multiplier){
      const baseValue = ValueMath.toNumber(value);
      const mult = ValueMath.toNumber(multiplier);
      if (baseValue <= 0 || mult <= 0) return 0;
      return ValueMath.divScale(baseValue, mult, MULTIPLIER_SCALE);
    }

    function computeDerivedStats(){
      const {
        critChance,
        critDamagePercent,
        apcMul,
        apsMul,
        apcFlat,
        apsFlat,
        inflRed,
        offlineBonus,
        globalMul,
        isoDiscount,
        hybridAPC,
        hybridAPS,
        frenzyBase,
        frenzyChargeBonus = 0,
        frenzyChargePercentScaled = 0,
        frenzySpawnBonusPercentScaled = 0,
        extraFrenzyDurationMs = 0,
        refundOnFailPercentScaled = 0,
        pityBonusPerFailPercentScaled = 0,
        pityMaxPercentScaled = 0
      } = computeFamilyEffects();
      currentFrenzyMultiplierBase = Math.max(1, frenzyBase);
      const apcFrenzyMultiplier = Math.max(1, getActiveApcFrenzyMultiplier());
      const apsFrenzyMultiplier = Math.max(1, getActiveApsFrenzyMultiplier());

      const apcBaseValue = Math.max(0, baseApc);
      const apsBaseValue = Math.max(0, baseAps);
      const apcFlatBonus = Math.max(0, apcFlat);
      const apsFlatBonus = Math.max(0, apsFlat);
      const apcFamilyPercent = Math.max(0, apcMul - MULTIPLIER_SCALE);
      const apsFamilyPercent = Math.max(0, apsMul - MULTIPLIER_SCALE);
      const apcFamilyBonusValue = (apcBaseValue > 0 && apcFamilyPercent > 0)
        ? ValueMath.divScale(apcBaseValue, apcFamilyPercent, MULTIPLIER_SCALE)
        : 0;
      const apsFamilyBonusValue = (apsBaseValue > 0 && apsFamilyPercent > 0)
        ? ValueMath.divScale(apsBaseValue, apsFamilyPercent, MULTIPLIER_SCALE)
        : 0;
      const apcAfterFamily = ValueMath.clampSafe(ValueMath.add(apcBaseValue, apcFamilyBonusValue));
      const apsAfterFamily = ValueMath.clampSafe(ValueMath.add(apsBaseValue, apsFamilyBonusValue));
      const apcAfterFlat = ValueMath.clampSafe(ValueMath.add(apcAfterFamily, apcFlatBonus));
      const apsAfterFlat = ValueMath.clampSafe(ValueMath.add(apsAfterFamily, apsFlatBonus));

      const apcFamilyMultiplier = apcBaseValue > 0 ? Math.max(0, apcAfterFamily) / apcBaseValue : 1;
      let APC = apcAfterFlat;
      const apcHybridMultiplier = (MULTIPLIER_SCALE + Math.max(0, hybridAPC)) / MULTIPLIER_SCALE;
      APC = applyMultiplier(APC, ValueMath.add(MULTIPLIER_SCALE, hybridAPC));
      const apcGlobalMultiplier = Math.max(0, globalMul) / MULTIPLIER_SCALE;
      APC = applyMultiplier(APC, globalMul);
      APC = ValueMath.clampSafe(ValueMath.mul(APC, apcFrenzyMultiplier));
      const apcShopMultiplier = getShopMultiplier(apcMultiLvl);
      APC = applyShopMultiplier(APC, apcMultiLvl);

      const apsFamilyMultiplier = apsBaseValue > 0 ? Math.max(0, apsAfterFamily) / apsBaseValue : 1;
      let APS = apsAfterFlat;
      const apsHybridMultiplier = (MULTIPLIER_SCALE + Math.max(0, hybridAPS)) / MULTIPLIER_SCALE;
      APS = applyMultiplier(APS, ValueMath.add(MULTIPLIER_SCALE, hybridAPS));
      const apsGlobalMultiplier = Math.max(0, globalMul) / MULTIPLIER_SCALE;
      APS = applyMultiplier(APS, globalMul);
      APS = ValueMath.clampSafe(ValueMath.mul(APS, apsFrenzyMultiplier));
      const apsShopMultiplier = getShopMultiplier(apsMultiLvl);
      APS = applyShopMultiplier(APS, apsMultiLvl);

      return {
        APC,
        APS,
        critChance,
        critDamagePercent,
        inflRed,
        offlineBonus,
        globalMul,
        isoDiscount,
        apcFlat: apcFlatBonus,
        apsFlat: apsFlatBonus,
        apcFrenzyMultiplier,
        apsFrenzyMultiplier,
        frenzyBase,
        apcBaseValue,
        apsBaseValue,
        apcAfterFamily,
        apcAfterFlat,
        apsAfterFamily,
        apsAfterFlat,
        apcFamilyMultiplier,
        apcHybridMultiplier,
        apcGlobalMultiplier,
        apcShopMultiplier,
        apsFamilyMultiplier,
        apsHybridMultiplier,
        apsGlobalMultiplier,
        apsShopMultiplier,
        frenzyChargeBonus: Math.max(0, frenzyChargeBonus),
        frenzyChargePercentScaled: Math.max(0, frenzyChargePercentScaled),
        frenzySpawnBonusPercentScaled: Math.max(0, frenzySpawnBonusPercentScaled),
        extraFrenzyDurationMs: Math.max(0, extraFrenzyDurationMs),
        refundOnFailPercentScaled: Math.max(0, refundOnFailPercentScaled),
        pityBonusPerFailPercentScaled: Math.max(0, pityBonusPerFailPercentScaled),
        pityMaxPercentScaled: Math.max(0, pityMaxPercentScaled)
      };
    }

    function getBonusLines(){
      const { critChance, critDamagePercent, apcMul, apsMul, apcFlat, apsFlat, inflRed, offlineBonus, globalMul, isoDiscount, hybridAPC, hybridAPS, frenzyBase } = computeFamilyEffects();
      const combinedApcMul = ValueMath.divScale(apcMul, ValueMath.add(MULTIPLIER_SCALE, hybridAPC), MULTIPLIER_SCALE);
      const combinedApsMul = ValueMath.divScale(apsMul, ValueMath.add(MULTIPLIER_SCALE, hybridAPS), MULTIPLIER_SCALE);
      const apcBonus = ValueMath.clampSafe(ValueMath.sub(combinedApcMul, MULTIPLIER_SCALE));
      const apsBonus = ValueMath.clampSafe(ValueMath.sub(combinedApsMul, MULTIPLIER_SCALE));
      const globalBonus = ValueMath.clampSafe(ValueMath.sub(globalMul, MULTIPLIER_SCALE));
      const lines = [];
      if (critChance > 0){
        const maxCritPercent = chanceScaledToPercent(Math.max(0, CRIT_SETTINGS.maxChanceScaled));
        lines.push(`+${chanceScaledToPercent(critChance)}% chance de coup critique (max ${maxCritPercent}%)`);
        lines.push(`+${formatNumber(critDamagePercent)}% dégâts critiques`);
      } else if (critDamagePercent > 100){
        lines.push(`+${formatNumber(critDamagePercent)}% dégâts critiques`);
      }
      if (apcFlat > 0) lines.push(`+${formatNumber(apcFlat)} APC (bonus plat)`);
      if (apcBonus > 0) lines.push(`+${scaledToPercent(apcBonus)}% APC (production manuelle)`);
      if (apsFlat > 0) lines.push(`+${formatNumber(apsFlat)} APS (bonus plat)`);
      if (apsBonus > 0) lines.push(`+${scaledToPercent(apsBonus)}% APS (production automatique)`);
      if (globalBonus > 0) lines.push(`+${scaledToPercent(globalBonus)}% multiplicateur global`);
      if (offlineBonus > 0) lines.push(`+${scaledToPercent(offlineBonus)}% APS offline`);
      if (inflRed > 0) lines.push(`-${scaledToPercent(inflRed)}% coût des tirages gacha`);
      if (isoDiscount > 0) lines.push(`-${scaledToPercent(isoDiscount)}% coût en isotopes`);
      const frenzyReady = Math.max(1, frenzyBase);
      const frenzyBaseDuration = Math.max(1, Math.round(APC_FRENZY_DURATION_MS / 1000));
      const frenzyAutoDuration = Math.max(1, Math.round(APS_FRENZY_DURATION_MS / 1000));
      if (frenzyReady > 1){
        const extra = frenzyReady - Math.max(1, FRENZY_BASE_MULTIPLIER);
        const extraText = extra > 0 ? ` (bonus AE +${formatNumber(extra)})` : "";
        lines.push(`Multiplicateur Frénésie : ×${formatNumber(frenzyReady)} APC pendant ${frenzyBaseDuration}s / APS pendant ${frenzyAutoDuration}s${extraText}`);
      }
      return lines;
    }

    function getFamilyOwnedCount(familyKey){
      let owned = 0;
      for (const el of ELEMENTS){
        if (el.family !== familyKey) continue;
        if (!gacha.owned[el.symbol]) continue;
        owned += 1;
      }
      return owned;
    }

    function isFamilySetComplete(familyKey){
      const required = FAMILY_SET_SIZES[familyKey] || 0;
      if (required <= 0) return false;
      return getFamilyOwnedCount(familyKey) >= required;
    }

    function getFamilySetStatuses(){
      return Object.entries(FAMILIES).map(([key, info])=>{
        const owned = getFamilyOwnedCount(key);
        const required = FAMILY_SET_SIZES[key] || 0;
        const complete = required > 0 && owned >= required;
        return { key, label: info.label, owned, required, complete };
      });
    }

    function getTrophyStatuses(){
      return AUTO_GACHA_TROPHIES.map(trophy => {
        const unlocked = !!trophies[trophy.key];
        const threshold = Math.max(1, trophy.threshold || 1);
        const progress = Math.min(1, totalAtoms / threshold);
        const currentValue = Math.min(totalAtoms, threshold);
        return {
          key: trophy.key,
          name: trophy.name,
          description: trophy.description,
          unlocked,
          threshold,
          progress,
          currentValue
        };
      });
    }

    function renderTrophyItems(){
      const statuses = getTrophyStatuses();
      return statuses
        .filter(status => status.unlocked)
        .map(status => {
          const currentText = formatNumber(status.currentValue);
          const targetText = formatNumber(status.threshold);
          return `<li class="trophy-unlocked"><div class="trophy-name">${status.name}</div><div class="trophy-desc">${status.description}</div><div class="trophy-progress"><span class="trophy-progress-value">Débloqué</span><span class="trophy-progress-target">${currentText} / ${targetText} Atoms</span></div></li>`;
        }).join("");
    }

    function showMoleculeResult(result){
      if (!moleculeResultEl) return;
      moleculeResultEl.classList.remove("success", "fail");
      if (!result || !result.message){
        moleculeResultEl.classList.add("hidden");
        moleculeResultEl.textContent = "";
        return;
      }
      moleculeResultEl.textContent = result.message;
      moleculeResultEl.classList.remove("hidden");
      moleculeResultEl.classList.add(result.success ? "success" : "fail");
    }

    function renderMoleculeCard(molecule, tierInfo = {}){
      const unlocked = isMoleculeUnlocked(molecule.key);
      const tierColor = sanitizeColorValue(tierInfo.color || "", "");
      const baseChance = Math.max(0, Math.min(CHANCE_SCALE, Math.floor(molecule.successChanceScaled || 0)));
      const pityScaled = getMoleculePityScaled(molecule.tier);
      const totalChance = Math.min(CHANCE_SCALE, baseChance + pityScaled);
      const currentChancePercent = chanceScaledToPercent(totalChance);
      const availability = evaluateMoleculeAvailability(molecule);
      let statusText;
      let noteText = "";
      if (unlocked){
        statusText = "Synthétisée";
      } else if (!availability.canAttempt){
        statusText = "Conditions requises";
        noteText = availability.reason || "";
      } else {
        statusText = `${currentChancePercent}% de réussite`;
      }
      const requirements = molecule.requirements || {};
      const requirementLines = [];
      if (requirements.awakenLevel){
        const hasLevel = getTotalAwakenCount() >= requirements.awakenLevel;
        requirementLines.push(`${hasLevel ? "✓" : "✗"} ${formatNumber(requirements.awakenLevel)} éveils`);
      }
      if (Array.isArray(requirements.familiesComplete)){
        for (const familyKey of requirements.familiesComplete){
          const label = FAMILIES[familyKey]?.label || familyKey;
          const complete = isFamilySetComplete(familyKey);
          requirementLines.push(`${complete ? "✓" : "✗"} Set ${label}`);
        }
      }
      const requirementsHtml = requirementLines.length
        ? `<ul class="molecule-reqs">${requirementLines.map(line => `<li>${escapeHtml(line)}</li>`).join("")}</ul>`
        : "";
      const families = getFamiliesForTier(molecule.tier);
      const familyLabels = families.map(code => FAMILIES[code]?.label || code);
      const metaParts = [
        `Coût : ${formatNumber(molecule.costIso)} iso`,
        `Réussite de base : ${chanceScaledToPercent(baseChance)}%`
      ];
      if (familyLabels.length){
        metaParts.push(`Groupes : ${familyLabels.join(', ')}`);
      }
      const controls = [];
      if (unlocked){
        controls.push(`<span class="molecule-note">Bonus actif</span>`);
      } else {
        controls.push(`<button type="button" class="molecule-action" data-molecule-key="${escapeHtml(molecule.key)}"${!availability.canAttempt ? " disabled" : ""}>Fusionner</button>`);
        if (noteText){
          controls.push(`<span class="molecule-note">${escapeHtml(noteText)}</span>`);
        }
      }
      const cardClasses = ["molecule-card"];
      if (unlocked) cardClasses.push("molecule-card--unlocked");
      if (tierColor) cardClasses.push("molecule-card--colored");
      const styleAttr = tierColor ? ` style="--molecule-color:${tierColor};"` : "";
      return `<article class="${cardClasses.join(' ')}"${styleAttr}><div class="molecule-card-header"><span class="molecule-formula">${escapeHtml(molecule.formula)}</span><span class="molecule-status">${escapeHtml(statusText)}</span></div><p class="molecule-summary">${escapeHtml(molecule.effectSummary)}</p><div class="molecule-meta">${metaParts.map(part => `<span>${escapeHtml(part)}</span>`).join('')}</div><div class="molecule-actions">${controls.join('')}</div>${requirementsHtml}</article>`;
    }

    function refreshMoleculeUI(){
      if (moleculeIsoStockEl) moleculeIsoStockEl.textContent = formatNumber(gacha.isotopes);
      if (moleculeDustEl) moleculeDustEl.textContent = formatNumber(getMoleculeDust());
      const unlocked = isMoleculeStationUnlocked();
      if (moleculeNoticeEl){
        if (!unlocked){
          const message = getMoleculeUnlockMessage() || "La station de synthèse est verrouillée.";
          moleculeNoticeEl.textContent = message;
          moleculeNoticeEl.classList.remove("hidden");
        } else {
          moleculeNoticeEl.textContent = "";
          moleculeNoticeEl.classList.add("hidden");
        }
      }
      if (moleculeListEl){
        if (!unlocked){
          moleculeListEl.innerHTML = "";
        } else {
          const tiers = (MOLECULE_TIERS.length ? MOLECULE_TIERS : DEFAULT_MOLECULE_TIERS);
          const sections = [];
          for (const tierInfo of tiers){
            const list = (MOLECULES_BY_TIER.get(tierInfo.key) || []);
            if (!list.length) continue;
            const pityScaled = getMoleculePityScaled(tierInfo.key);
            const tierMeta = [`Bonus de pitié : +${chanceScaledToPercent(pityScaled)}%`];
            const families = getFamiliesForTier(tierInfo.key);
            if (families.length){
              const labels = families.map(code => FAMILIES[code]?.label || code);
              tierMeta.push(`Familles : ${labels.join(', ')}`);
            }
            const cards = list.map(molecule => renderMoleculeCard(molecule, tierInfo)).join("");
            sections.push(`<section class="molecule-tier"><div class="molecule-tier-header"><h2 class="molecule-tier-title">${escapeHtml(tierInfo.label)}</h2><div class="molecule-tier-meta">${tierMeta.map(entry => `<span>${escapeHtml(entry)}</span>`).join('')}</div></div>${cards}</section>`);
          }
          moleculeListEl.innerHTML = sections.join("");
        }
      }
      const lastResult = unlocked ? getMoleculeLastResult() : null;
      showMoleculeResult(lastResult);
    }

    function refreshBonusList(){
      if (infosBonusLinesEl && infosBonusEmptyEl){
        const lines = getBonusLines();
        if (!lines.length){
          infosBonusLinesEl.innerHTML = "";
          infosBonusLinesEl.classList.add("hidden");
          infosBonusEmptyEl.classList.remove("hidden");
        } else {
          infosBonusLinesEl.innerHTML = lines.map(line => `<li>${line}</li>`).join("");
          infosBonusLinesEl.classList.remove("hidden");
          infosBonusEmptyEl.classList.add("hidden");
        }
      }

      if (infosTrophyListEl && infosTrophyEmptyEl){
        const trophyItems = renderTrophyItems();
        if (trophyItems){
          infosTrophyListEl.innerHTML = trophyItems;
          infosTrophyListEl.classList.remove("hidden");
          infosTrophyEmptyEl.classList.add("hidden");
        } else {
          infosTrophyListEl.innerHTML = "";
          infosTrophyListEl.classList.add("hidden");
          infosTrophyEmptyEl.classList.remove("hidden");
        }
      }

      if (infosSetStatusEl && infosSetEmptyEl){
        const setStatuses = getFamilySetStatuses();
        if (setStatuses.length){
          const cards = setStatuses.map(status => {
            const progress = status.required > 0 ? `${status.owned} / ${status.required}` : `${status.owned}`;
            const stateText = status.complete ? "Bonus de set activé" : "Bonus de set inactif";
            const statusClass = status.complete ? "set-status-card set-complete" : "set-status-card set-incomplete";
            return `<div class="${statusClass}"><span class="set-status-name">${status.label}</span><span class="set-status-info"><span class="set-status-progress">${progress}</span><span class="set-status-state">${stateText}</span></span></div>`;
          }).join("");
          infosSetStatusEl.innerHTML = cards;
          infosSetStatusEl.classList.remove("hidden");
          const hasProgress = setStatuses.some(status => status.owned > 0 || status.complete);
          if (hasProgress){
            infosSetEmptyEl.classList.add("hidden");
          } else {
            infosSetEmptyEl.classList.remove("hidden");
          }
        } else {
          infosSetStatusEl.innerHTML = "";
          infosSetStatusEl.classList.add("hidden");
          infosSetEmptyEl.classList.remove("hidden");
        }
      }

      if (infosMoleculeListEl && infosMoleculeEmptyEl){
        const molecules = getUnlockedMolecules();
        if (molecules.length){
          const items = molecules.map(molecule => `<li><strong>${escapeHtml(molecule.formula)}</strong> – ${escapeHtml(molecule.effectSummary)}</li>`).join("");
          infosMoleculeListEl.innerHTML = items;
          infosMoleculeListEl.classList.remove("hidden");
          infosMoleculeEmptyEl.classList.add("hidden");
        } else {
          infosMoleculeListEl.innerHTML = "";
          infosMoleculeListEl.classList.add("hidden");
          infosMoleculeEmptyEl.classList.remove("hidden");
        }
      }
    }

    function refreshAwakenHighlights(){
      updateAwakenDiscountCounter();
      if (!cellMap.size) return;
      for (const [symbol, cell] of cellMap.entries()){
        if (!cell) continue;
        const owned = !!gacha.owned[symbol];
        const level = getAwakenLevel(symbol);
        const baseCost = getAwakenCost(level);
        const isoAmount = getIsoStock(symbol);
        let canAwaken = false;
        if (owned && baseCost != null && level < AWAKEN_MAX){
          const discounted = getDiscountedAwakenCost(level, currentIsoDiscount);
          canAwaken = discounted != null && isoAmount >= discounted;
        }
        cell.classList.toggle("awaken-ready", !!canAwaken);
      }
      updateAwakenAllButton();
    }

    function updateAwakenDiscountCounter(){
      if (!awakenDiscountCounter) return;
      const steps = getAwakenDiscountSteps();
      const discountScaled = getAwakenDiscountScaled();
      const percent = scaledToPercent(discountScaled);
      const percentText = percent > 0 ? ` (−${percent}%)` : "";
      awakenDiscountCounter.textContent = `Rabais éveil : ${formatNumber(steps)}${percentText}`;
      awakenDiscountCounter.classList.toggle("has-discount", steps > 0);
    }

    function clampRollDiscount(value){
      if (!Number.isFinite(value)) return 0;
      const maxCap = Math.max(0, Math.min(GACHA_DISCOUNT_CAP_SCALED, MULTIPLIER_SCALE));
      return Math.max(0, Math.min(Math.floor(value), maxCap));
    }

    function getDiscountedRollCost(baseCost, discountScaled = 0){
      const base = Math.max(0, Math.floor(baseCost));
      if (base <= 0) return 0;
      const discount = clampRollDiscount(discountScaled);
      const adjusted = ValueMath.sub(MULTIPLIER_SCALE, discount);
      if (adjusted <= 0) return 1;
      return Math.max(1, ValueMath.divScale(base, adjusted, MULTIPLIER_SCALE));
    }

    function computeNextRollCost(currentCost){
      const cost = Math.max(0, Math.floor(currentCost));
      if (cost >= GACHA_LINEAR_THRESHOLD){
        return ValueMath.add(cost, Math.max(0, GACHA_LINEAR_INCREMENT));
      }
      const growth = ValueMath.add(MULTIPLIER_SCALE, Math.max(0, GACHA_PERCENT_GROWTH_SCALED));
      return Math.max(1, ValueMath.divScale(cost, growth, MULTIPLIER_SCALE));
    }

    function computeBulkRollCost(quantity, { baseCost = gacha.rollCost, discount = currentRollDiscount } = {}){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return 0;
      let total = 0;
      let cost = Math.max(0, toNonNegativeInt(baseCost));
      const discountScaled = clampRollDiscount(discount);
      for (let i = 0; i < qty; i++){
        const stepCost = getDiscountedRollCost(cost, discountScaled);
        if (!Number.isFinite(stepCost) || stepCost >= Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
        if (total > Number.MAX_SAFE_INTEGER - stepCost) return Number.MAX_SAFE_INTEGER;
        total = ValueMath.add(total, stepCost);
        cost = computeNextRollCost(cost);
      }
      return total;
    }

    /* ===================== Grille périodique ===================== */
    function buildPeriodicGrids(){
      if (!gridMain) return;
      gridMain.innerHTML = "";
      cellMap.clear();
      if (gachaInfoPanel) gridMain.appendChild(gachaInfoPanel);
      if (awakenWrapper){
        gridMain.appendChild(awakenWrapper);
        awakenWrapper.classList.add("hidden");
      }
      if (awakenSingleCard) awakenSingleCard.classList.add("hidden");
      if (awakenBtn){
        awakenBtn.textContent = "Éveil";
        awakenBtn.disabled = true;
        awakenBtn.classList.add("hidden");
        awakenBtn.removeAttribute("title");
      }
      if (awakenAllCard) awakenAllCard.classList.add("hidden");
      if (awakenAllBtn){
        awakenAllBtn.classList.add("hidden");
        awakenAllBtn.disabled = true;
        awakenAllBtn.removeAttribute("title");
      }
      if (elementName) elementName.textContent = "Clique un élément dans la grille";
      if (elementIsoCount) elementIsoCount.textContent = "—";
      // Périodes 1–7 (hors cases "*")
      for (let period=1; period<=7; period++){
        const row = PERIODS[period];
        for (let c=1; c<=18; c++){
          const sym = row[c-1] || "";
          if (!sym || sym==="*") continue;
          const el = ELEMENTS.find(e=>e.symbol===sym && !e.frow);
          const cell = document.createElement("div");
          const colors = FAMILY_COLORS[el.family] || {};
          cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
          cell.style.gridColumn = c;
          cell.style.gridRow = period;
          if (colors.base) cell.style.setProperty("--bg-base", colors.base);
          if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
          cell.dataset.symbol = el.symbol;
          cell.dataset.family = el.family;
          cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
          cell.addEventListener("click", ()=> showElementInfo(el));
          cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
          gridMain.appendChild(cell);
          cellMap.set(el.symbol, cell);
        }
      }
      // Lanthanides row (col 4->18)
      const lanRowIndex = 8;
      LANTHANIDES.forEach((sym,i)=>{
        const el = ELEMENTS.find(e=>e.symbol===sym);
        const cell = document.createElement("div");
        const colors = FAMILY_COLORS[el.family] || {};
        cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
        cell.style.gridColumn = (4+i);
        cell.style.gridRow = lanRowIndex;
        if (colors.base) cell.style.setProperty("--bg-base", colors.base);
        if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
        cell.dataset.symbol = el.symbol;
        cell.dataset.family = el.family;
        cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
        cell.addEventListener("click", ()=> showElementInfo(el));
        cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
        gridMain.appendChild(cell);
        cellMap.set(el.symbol, cell);
      });
      // Actinides row (col 4->18)
      const actRowIndex = 9;
      ACTINIDES.forEach((sym,i)=>{
        const el = ELEMENTS.find(e=>e.symbol===sym);
        const cell = document.createElement("div");
        const colors = FAMILY_COLORS[el.family] || {};
        cell.className = `cell${gacha.owned[el.symbol] ? ' owned' : ''}`;
        cell.style.gridColumn = (4+i);
        cell.style.gridRow = actRowIndex;
        if (colors.base) cell.style.setProperty("--bg-base", colors.base);
        if (colors.owned) cell.style.setProperty("--bg-owned", colors.owned);
        cell.dataset.symbol = el.symbol;
        cell.dataset.family = el.family;
        cell.innerHTML = `<div class="Z">${el.Z}</div><div class="sym">${el.symbol}</div>`;
        cell.addEventListener("click", ()=> showElementInfo(el));
        cell.addEventListener("dblclick", event => handleCellDoubleClick(el, event));
        gridMain.appendChild(cell);
        cellMap.set(el.symbol, cell);
      });
      if (awakenDiscountCounter) gridMain.appendChild(awakenDiscountCounter);
      refreshAwakenHighlights();
    }

    function refreshElementPanel({ forceRecompute = false } = {}){
      if (forceRecompute){
        const derived = computeDerivedStats();
        currentIsoDiscount = derived.isoDiscount || 0;
        currentRollDiscount = clampRollDiscount(derived.inflRed || 0);
      }
      if (!currentElement){
        if (elementName) elementName.textContent = "Clique un élément dans la grille";
        if (elementIsoCount) elementIsoCount.textContent = "—";
        if (elementFamily) elementFamily.textContent = "Famille : —";
        if (awakenBtn){
          awakenBtn.textContent = "Éveil";
          awakenBtn.disabled = true;
          awakenBtn.classList.add("hidden");
          awakenBtn.removeAttribute("title");
        }
        if (awakenSingleCard) awakenSingleCard.classList.add("hidden");
        updateAwakenAllButton();
        return;
      }
      const el = currentElement;
      const owned = !!gacha.owned[el.symbol];
      const isoAmount = getIsoStock(el.symbol);
      const awakenLevel = getAwakenLevel(el.symbol);
      const maxLevel = Math.min(AWAKEN_MAX, AWAKEN_COSTS.length);
      if (elementName) elementName.textContent = `${el.name} (${el.symbol})`;
      if (elementFamily){
        const familyDef = FAMILIES[el.family] || {};
        const familyLabel = familyDef.label || el.family;
        const bonusLabel = familyDef.bonusDesc || "";
        const bonusText = bonusLabel ? ` (Bonus: ${bonusLabel})` : "";
        elementFamily.textContent = `Famille : ${familyLabel}${bonusText}`;
      }
      if (elementIsoCount) elementIsoCount.textContent = formatNumber(isoAmount);
      if (!awakenWrapper || !awakenBtn) return;
      awakenBtn.classList.remove("hidden");
      if (awakenSingleCard) awakenSingleCard.classList.remove("hidden");
      const progressText = `(${awakenLevel}/${maxLevel})`;
      const baseCost = getDiscountedAwakenCost(awakenLevel, currentIsoDiscount);
      const costText = baseCost != null ? `${formatNumber(baseCost)} iso` : "—";
      if (!owned){
        awakenBtn.textContent = `Éveil : ${costText} ${progressText}`;
        awakenBtn.disabled = true;
        awakenBtn.title = "Obtiens cet élément pour l'éveiller";
      } else if (awakenLevel >= maxLevel){
        awakenBtn.textContent = `Éveil max ${progressText}`;
        awakenBtn.disabled = true;
        awakenBtn.removeAttribute("title");
      } else {
        const discountLabel = currentIsoDiscount > 0 ? ` (-${scaledToPercent(currentIsoDiscount)}%)` : "";
        const isoText = baseCost != null ? `${formatNumber(baseCost)} iso${discountLabel}` : costText;
        awakenBtn.textContent = `Éveil : ${isoText} ${progressText}`;
        awakenBtn.disabled = baseCost == null || isoAmount < baseCost;
        if (awakenBtn.disabled && baseCost != null){
          awakenBtn.title = `Requiert ${formatNumber(baseCost)} isotopes`;
        } else {
          awakenBtn.removeAttribute("title");
        }
      }
      updateAwakenAllButton();
      if (forceRecompute) refreshAwakenHighlights();
    }

    function showElementInfo(el){
      currentElement = el;
      refreshElementPanel({ forceRecompute: true });
    }

    function handleCellDoubleClick(el, event){
      if (!el) return;
      if (event){
        event.preventDefault();
        event.stopPropagation();
      }
      showElementInfo(el);
      attemptAwaken();
    }

    function attemptAwaken(){
      if (!currentElement) return;
      const el = currentElement;
      if (!gacha.owned[el.symbol]) return;
      const level = getAwakenLevel(el.symbol);
      if (level >= AWAKEN_MAX) return;
      const derived = computeDerivedStats();
      currentIsoDiscount = derived.isoDiscount || 0;
      currentRollDiscount = clampRollDiscount(derived.inflRed || 0);
      const cost = getDiscountedAwakenCost(level, currentIsoDiscount);
      if (cost == null) return;
      if (!spendIsotopes(el.symbol, cost)) return;
      setAwakenLevel(el.symbol, level + 1);
      registerAwakenProgress(1);
      saveAndUpdate();
      refreshElementPanel();
    }

    function attemptAwakenAll(){
      if (!hasFullCollection()) return;
      const derived = computeDerivedStats();
      currentIsoDiscount = derived.isoDiscount || 0;
      currentRollDiscount = clampRollDiscount(derived.inflRed || 0);
      if (!canAnyAwaken(currentIsoDiscount)){
        updateAwakenAllButton();
        return;
      }
      let upgraded = 0;
      let guard = 0;
      const maxLoops = AWAKEN_MAX * ORDERED_SYMBOLS.length;
      let progress = true;
      while (progress && guard < maxLoops){
        progress = false;
        guard++;
        for (const symbol of ORDERED_SYMBOLS){
          if (!gacha.owned[symbol]) continue;
          while (true){
            const level = getAwakenLevel(symbol);
            if (level >= AWAKEN_MAX) break;
            const cost = getDiscountedAwakenCost(level, currentIsoDiscount);
            if (cost == null) break;
            if (!spendIsotopes(symbol, cost)) break;
            setAwakenLevel(symbol, level + 1);
            registerAwakenProgress(1);
            upgraded++;
            progress = true;
            const nextDerived = computeDerivedStats();
            currentIsoDiscount = nextDerived.isoDiscount || 0;
            currentRollDiscount = clampRollDiscount(nextDerived.inflRed || 0);
          }
        }
      }
      if (upgraded > 0){
        saveAndUpdate();
      } else {
        updateAwakenAllButton();
      }
    }

    /* ===================== Tirage Gacha ===================== */
    function rollGacha({ free = false, displayResult = true } = {}){
      const baseCost = gacha.rollCost;
      const discountScaled = clampRollDiscount(currentRollDiscount);
      const cost = getDiscountedRollCost(baseCost, discountScaled);
      if (!free && atoms < cost) return null;

      if (!free){
        atoms = ValueMath.clampSafe(ValueMath.sub(atoms, cost));
        gacha.rollCost = computeNextRollCost(baseCost);
      }

      // Choix famille puis élément aléatoire dans cette famille
      const fam = pickFamily();
      const pool = ELEMENTS.filter(e=>e.family===fam);
      if (!pool.length) return null;
      const el = pool[Math.floor(Math.random()*pool.length)];

      gacha.pulls++;
      let first = false;
      let lootRarity = null;
      let isoGain = 0;
      if (gacha.owned[el.symbol]){
        gacha.dupes[el.symbol] = (gacha.dupes[el.symbol]||0) + 1;
        lootRarity = rollLootRarity();
        isoGain = lootRarity.multiplier;
        addIsotopes(el.symbol, isoGain);
      } else {
        gacha.owned[el.symbol] = 1;
        first = true;
      }

      // Feedback UI : encart loot + mise à jour grille
      if (displayResult){
        if (lastLootBox) lastLootBox.classList.remove("hidden");
        if (lastLootName) lastLootName.textContent = `${el.name} (${el.symbol})`;
        if (lastLootFam) lastLootFam.textContent = `${FAMILIES[fam]?.label || fam}`;
        if (first){
          setLootResultClass("is-new");
          if (lastLootType) lastLootType.textContent = "Nouveau!";
        } else if (lootRarity){
          setLootResultClass(`rarity-${lootRarity.key}`);
          if (lastLootType) lastLootType.textContent = `Doublons x${lootRarity.multiplier}`;
        } else {
          setLootResultClass(null);
          if (lastLootType) lastLootType.textContent = "—";
        }
      }

      // Surbrillance de la case
      [...document.querySelectorAll('[data-symbol]')].forEach(n=>{
        if (n.dataset.symbol===el.symbol) n.classList.add('owned');
      });

      return { element: el, family: fam, isNew: first, lootRarity, isoGain };
    }

    /* ===================== Interactions & Boucles ===================== */
    function prepareResetModal(){
      if (!resetWordEl) return;
      const word = RESET_WORDS[Math.floor(Math.random() * RESET_WORDS.length)] || "reset";
      currentResetWord = word;
      resetWordEl.textContent = word;
      if (resetInput) resetInput.value = "";
      if (resetConfirmBtn) resetConfirmBtn.disabled = true;
      if (typeof updateResetConfirmState === "function") updateResetConfirmState();
      setTimeout(()=>{ if (resetInput) resetInput.focus(); }, 50);
    }

    function openResetModal(){
      if (!resetModal) return;
      prepareResetModal();
      resetModal.classList.remove("hidden");
    }

    function closeResetModal(){
      if (!resetModal) return;
      resetModal.classList.add("hidden");
      currentResetWord = "";
      if (resetInput) resetInput.value = "";
      if (resetConfirmBtn) resetConfirmBtn.disabled = true;
    }

    function performRevive(){
      const tier = getReviveTier(reviveCount);
      if (!tier) return false;
      const cost = tier.cost;
      if (!Number.isFinite(cost) || cost <= 0) return false;
      if (atoms < cost) return false;
      atoms = ValueMath.clampSafe(ValueMath.sub(atoms, cost));
      reviveCount += 1;
      reviveUnlocked = true;
      const baseValues = getReviveBaseStartValue(reviveCount);
      baseApc = baseValues.apc;
      baseAps = baseValues.aps;
      apcLvl = 0;
      autoLvl = 0;
      apcMultiLvl = 0;
      apsMultiLvl = 0;
      trophies = {};
      const now = Date.now();
      last = now;
      sessionStartTime = now;
      sessionManualClicks = 0;
      sessionAtomsGained = 0;
      reviveRunAtoms = 0;
      reviveRunClicks = 0;
      currentElement = null;
      currentIsoDiscount = 0;
      currentRollDiscount = 0;
      apcFrenzyEffects = [];
      apsFrenzyEffects = [];
      currentFrenzyMultiplierBase = 5;
      hideApcFrenzyOrb();
      hideApsFrenzyOrb();
      resetAutoGachaCooldown();
      lastAutoResult = null;
      updateAutoGachaHeader();
      gacha = createDefaultGachaState();
      syncTotalIsotopes();
      if (autoGachaPanel) autoGachaPanel.classList.add("hidden");
      if (lastLootBox) lastLootBox.classList.add("hidden");
      if (lastLootName) lastLootName.textContent = "—";
      if (lastLootFam) lastLootFam.textContent = "—";
      setLootResultClass(null);
      if (lastLootType) lastLootType.textContent = "—";
      atoms = 0;
      buildPeriodicGrids();
      updateReviveNavState();
      saveAll();
      updateUI();
      return true;
    }

    function performReset(){
      atoms = 0;
      reviveCount = 0;
      reviveRunAtoms = 0;
      reviveRunClicks = 0;
      reviveUnlocked = false;
      const baseValues = getReviveBaseStartValue(0);
      baseApc = baseValues.apc;
      baseAps = baseValues.aps;
      apcLvl = 0;
      autoLvl = 0;
      apcMultiLvl = 0;
      apsMultiLvl = 0;
      totalAtoms = 0;
      trophies = {};
      last = Date.now();
      manualClicksTotal = 0;
      sessionManualClicks = 0;
      sessionAtomsGained = 0;
      sessionStartTime = Date.now();
      gameStart = sessionStartTime;
      gacha = createDefaultGachaState();
      syncTotalIsotopes();
      currentElement = null;
      currentIsoDiscount = 0;
      currentRollDiscount = 0;
      apcFrenzyEffects = [];
      apsFrenzyEffects = [];
      currentFrenzyMultiplierBase = 5;
      hideApcFrenzyOrb();
      hideApsFrenzyOrb();
      resetAutoGachaCooldown();
      lastAutoResult = null;
      updateAutoGachaHeader();
      if (autoGachaPanel) autoGachaPanel.classList.add("hidden");
      if (lastLootBox) lastLootBox.classList.add("hidden");
      if (lastLootName) lastLootName.textContent = "—";
      if (lastLootFam) lastLootFam.textContent = "—";
      setLootResultClass(null);
      if (lastLootType) lastLootType.textContent = "—";
      localStorage.removeItem("miniAtomState");
      localStorage.removeItem("gacha");
      buildPeriodicGrids();
      updateReviveNavState();
      saveAll();
      updateUI();
    }

    // Clic partout sur la page principale
    if (mainPageEl){
      mainPageEl.addEventListener("click", ()=>{
        manualClicksTotal += 1;
        sessionManualClicks += 1;
        reviveRunClicks += 1;
        const { APC, critChance, critDamagePercent } = computeDerivedStats();
        let gain = ValueMath.clampSafe(toNonNegativeInt(APC));
        let isCrit = false;
        if (critChance > 0){
          const roll = Math.floor(Math.random() * CHANCE_SCALE);
          isCrit = roll < critChance;
          if (isCrit){
            const critGain = ValueMath.divScale(gain, critDamagePercent, 100, { round: "floor" });
            gain = Math.max(gain, critGain);
          }
        }
        addAtoms(gain);
        animateAtom(isCrit);
        updateUI();
      });
    }

    if (apcFrenzyOrbEl){
      apcFrenzyOrbEl.addEventListener("click", event=>{
        event.preventDefault();
        event.stopPropagation();
        playPopSound();
        hideApcFrenzyOrb();
        triggerApcFrenzyBonus();
      });
    }

    if (apsFrenzyOrbEl){
      apsFrenzyOrbEl.addEventListener("click", event=>{
        event.preventDefault();
        event.stopPropagation();
        playPopSound();
        hideApsFrenzyOrb();
        triggerApsFrenzyBonus();
      });
    }

    if (awakenBtn){
      awakenBtn.addEventListener("click", attemptAwaken);
    }
    if (awakenAllBtn){
      awakenAllBtn.addEventListener("click", attemptAwakenAll);
    }

    // Améliorations de base
    const baseApcCost = getNumberFromConfig(["shop", "apc", "baseCost"], 15, { min: 1, integer: true });
    const apcStageSize = getNumberFromConfig(["shop", "apc", "stageSize"], 100, { min: 1, integer: true });
    const baseAutoCost = getNumberFromConfig(["shop", "auto", "baseCost"], 50, { min: 1, integer: true });
    const autoStageSize = getNumberFromConfig(["shop", "auto", "stageSize"], apcStageSize, { min: 1, integer: true });

    const multiplierBaseCost = getNumberFromConfig(["shop", "multiplier", "baseCost"], 1_000_000, { min: 1, integer: true });
    const multiplierCostFactor = getNumberFromConfig(["shop", "multiplier", "costFactor"], 10, { min: Number.EPSILON });
    const multiplierBaseValue = getNumberFromConfig(["shop", "multiplier", "baseValue"], 1, { min: 0 });
    const multiplierIncrementPerLevel = getNumberFromConfig(["shop", "multiplier", "incrementPerLevel"], 1, { min: 0 });

    const shopIncrementBase = getNumberFromConfig(["shop", "increment", "base"], 1, { min: 1, integer: true });
    const shopIncrementGrowthFactor = getNumberFromConfig(["shop", "increment", "growthFactor"], 2, { min: Number.EPSILON });

    function computeUpgradeCost(baseCost, level, baseIncrement, stageSize){
      const base = Math.max(1, baseCost);
      const increment = Math.max(0, toNonNegativeInt(baseIncrement ?? base));
      const lvl = Math.max(0, toNonNegativeInt(level));
      const span = Math.max(1, toNonNegativeInt(stageSize ?? 1));
      if (lvl <= 0) return base;

      let totalIncrease = 0;
      let step = increment;

      for (let stage = 0; ; stage++){
        const stageStart = stage === 0 ? 0 : stage * span - 1;
        if (stageStart >= lvl) break;
        if (stage > 0){
          if (!Number.isFinite(step) || step > Number.MAX_SAFE_INTEGER / 2){
            return Number.MAX_SAFE_INTEGER;
          }
          step *= 2;
        }
        const stageEnd = (stage + 1) * span - 2;
        const effectiveEnd = Math.min(lvl - 1, stageEnd);
        if (effectiveEnd < stageStart) continue;
        const count = effectiveEnd - stageStart + 1;
        if (!Number.isFinite(step) || step > Number.MAX_SAFE_INTEGER / Math.max(1, count)){
          return Number.MAX_SAFE_INTEGER;
        }
        const stageIncrease = ValueMath.mul(step, count);
        if (!Number.isFinite(stageIncrease) || stageIncrease > Number.MAX_SAFE_INTEGER - totalIncrease){
          return Number.MAX_SAFE_INTEGER;
        }
        totalIncrease = ValueMath.add(totalIncrease, stageIncrease);
      }

      const total = ValueMath.add(base, totalIncrease);
      if (!Number.isFinite(total) || total > Number.MAX_SAFE_INTEGER){
        return Number.MAX_SAFE_INTEGER;
      }
      return Math.max(1, Math.floor(total));
    }

    const apcCost = lvl => computeUpgradeCost(baseApcCost, lvl, baseApcCost, apcStageSize);
    const autoCost = lvl => computeUpgradeCost(baseAutoCost, lvl, baseAutoCost, autoStageSize);

    function computeBulkUpgradeCost(costFn, startLevel, quantity){
      if (typeof costFn !== "function") return Number.MAX_SAFE_INTEGER;
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return 0;
      let total = 0;
      let level = Math.max(0, toNonNegativeInt(startLevel));
      for (let i = 0; i < qty; i++){
        const stepCost = toNonNegativeInt(costFn(level));
        if (!Number.isFinite(stepCost) || stepCost >= Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;
        if (total > Number.MAX_SAFE_INTEGER - stepCost) return Number.MAX_SAFE_INTEGER;
        total = ValueMath.add(total, stepCost);
        level++;
      }
      return total;
    }

    function computeMultiplierCost(level){
      const lvl = Math.max(0, toNonNegativeInt(level));
      let cost = multiplierBaseCost;
      const factor = Math.max(Number.EPSILON, multiplierCostFactor);
      for (let i = 0; i < lvl; i++){
        if (!Number.isFinite(cost) || cost > Number.MAX_SAFE_INTEGER / factor){
          return Number.MAX_SAFE_INTEGER;
        }
        cost = ValueMath.mul(cost, factor);
      }
      if (!Number.isFinite(cost)) return Number.MAX_SAFE_INTEGER;
      return Math.max(1, Math.floor(cost));
    }

    function getShopMultiplier(level){
      const lvl = Math.max(0, toNonNegativeInt(level));
      const base = Math.max(0, multiplierBaseValue);
      const increment = Math.max(0, multiplierIncrementPerLevel);
      const multiplier = ValueMath.add(base, ValueMath.mul(lvl, increment));
      const safeMultiplier = Number.isFinite(multiplier) ? multiplier : base;
      if (!Number.isFinite(safeMultiplier)) return 1;
      return Math.max(0, safeMultiplier);
    }

    function applyShopMultiplier(value, level){
      const baseValue = ValueMath.clampSafe(toNonNegativeInt(value));
      if (baseValue <= 0) return 0;
      const multiplier = getShopMultiplier(level);
      if (!Number.isFinite(multiplier) || multiplier <= 0) return 0;
      const result = ValueMath.mul(baseValue, multiplier);
      if (!Number.isFinite(result) || result > Number.MAX_SAFE_INTEGER){
        return Number.MAX_SAFE_INTEGER;
      }
      return ValueMath.clampSafe(Math.floor(result));
    }

    function attemptFlatUpgrade(type, quantity){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return false;
      const costFn = type === "apc" ? apcCost : autoCost;
      const currentLevel = type === "apc" ? apcLvl : autoLvl;
      const totalCost = computeBulkUpgradeCost(costFn, currentLevel, qty);
      if (!Number.isFinite(totalCost) || totalCost <= 0) return false;
      if (atoms < totalCost) return false;
      const increment = ValueMath.clampSafe(toNonNegativeInt(getReviveShopIncrementValue()));
      if (increment <= 0) return false;
      const totalIncrement = ValueMath.mul(increment, qty);
      if (!Number.isFinite(totalIncrement)) return false;
      if (type === "apc"){
        const newBase = ValueMath.add(baseApc, totalIncrement);
        if (!Number.isFinite(newBase)) return false;
        atoms = ValueMath.clampSafe(ValueMath.sub(atoms, totalCost));
        baseApc = newBase;
        apcLvl += qty;
      } else {
        const newBase = ValueMath.add(baseAps, totalIncrement);
        if (!Number.isFinite(newBase)) return false;
        atoms = ValueMath.clampSafe(ValueMath.sub(atoms, totalCost));
        baseAps = newBase;
        autoLvl += qty;
      }
      saveAndUpdate();
      return true;
    }

    if (btnBuyApc) btnBuyApc.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 1); });
    if (btnBuyApc10) btnBuyApc10.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 10); });
    if (btnBuyApc100) btnBuyApc100.addEventListener("click", ()=>{ attemptFlatUpgrade("apc", 100); });
    if (btnBuyAuto) btnBuyAuto.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 1); });
    if (btnBuyAuto10) btnBuyAuto10.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 10); });
    if (btnBuyAuto100) btnBuyAuto100.addEventListener("click", ()=>{ attemptFlatUpgrade("aps", 100); });
    if (btnBuyApcMulti) btnBuyApcMulti.addEventListener("click", ()=>{
      const cost = computeMultiplierCost(apcMultiLvl);
      if (atoms >= cost){
        atoms = ValueMath.clampSafe(ValueMath.sub(atoms, cost));
        apcMultiLvl++;
        saveAndUpdate();
      }
    });
    if (btnBuyApsMulti) btnBuyApsMulti.addEventListener("click", ()=>{
      const cost = computeMultiplierCost(apsMultiLvl);
      if (atoms >= cost){
        atoms = ValueMath.clampSafe(ValueMath.sub(atoms, cost));
        apsMultiLvl++;
        saveAndUpdate();
      }
    });

    if (reviveBuyBtn){
      reviveBuyBtn.addEventListener("click", ()=>{
        performRevive();
      });
    }

    function performBulkRoll(quantity){
      const qty = Math.max(0, toNonNegativeInt(quantity));
      if (qty <= 0) return false;
      const totalCost = computeBulkRollCost(qty, { baseCost: gacha.rollCost, discount: currentRollDiscount });
      if (!Number.isFinite(totalCost) || atoms < totalCost) return false;
      let success = false;
      for (let i = 0; i < qty; i++){
        const result = rollGacha({ displayResult:false });
        if (!result) break;
        success = true;
      }
      if (success) saveAndUpdate();
      return success;
    }

    // Tirage
    if (rollBtn) rollBtn.addEventListener("click", ()=>{
      const result = rollGacha();
      if (result) saveAndUpdate();
    });
    if (roll10Btn) roll10Btn.addEventListener("click", ()=>{
      performBulkRoll(10);
    });
    if (roll100Btn) roll100Btn.addEventListener("click", ()=>{
      performBulkRoll(100);
    });

    if (moleculeListEl){
      moleculeListEl.addEventListener("click", event => {
        const button = event.target.closest(".molecule-action");
        if (!button || button.disabled) return;
        const key = button.dataset.moleculeKey;
        if (!key) return;
        const result = attemptMoleculeFusion(key);
        if (!result) return;
        if (result.attempted) saveAll();
        updateUI();
        showMoleculeResult(result);
      });
    }

    // Navigation
    const pageElements = new Map([
      ["mainPage", mainPageEl],
      ["shopPage", shopPageEl],
      ["gachaPage", gachaPageEl],
      ["moleculesPage", moleculesPageEl],
      ["infosPage", infosPageEl],
      ["revivePage", revivePageEl],
      ["optionsPage", optionsPageEl]
    ]);

    /**
     * Active la page demandée et synchronise l'état du menu.
     * Cette fonction centralise toute la logique de navigation pour
     * éviter les oublis lors de l'ajout de nouvelles pages.
     */
    function activatePage(pageId){
      if (pageId === "revivePage" && !reviveUnlocked){
        pageId = "mainPage";
      }
      if (!pageElements.has(pageId)) return;
      pageElements.forEach((pageEl, id)=>{
        if (!pageEl) return;
        if (id === pageId){
          pageEl.classList.add("active");
        } else {
          pageEl.classList.remove("active");
        }
      });
      navButtons.forEach(btn=>{
        const target = btn.dataset.pageTarget;
        const isActive = target === pageId;
        btn.classList.toggle("active", isActive);
        if (isActive){
          btn.setAttribute("aria-current", "page");
        } else {
          btn.removeAttribute("aria-current");
        }
      });
      if (pageId !== "mainPage"){
        hideApcFrenzyOrb();
        hideApsFrenzyOrb();
      }
      updateUI();
    }

    navButtons.forEach(btn=>{
      btn.addEventListener("click", ()=>{
        if (btn.disabled) return;
        const target = btn.dataset.pageTarget;
        if (target === "revivePage" && !reviveUnlocked) return;
        if (target) activatePage(target);
      });
    });

    // Thèmes
    themeButtons.forEach(btn=>{
      btn.addEventListener("click", ()=>{
        applyTheme(btn.dataset.theme);
      });
    });

    function updateResetConfirmState(){
      if (!resetConfirmBtn) return;
      const inputValue = resetInput ? resetInput.value : "";
      const matches = normalizeWord(inputValue) === normalizeWord(currentResetWord);
      resetConfirmBtn.disabled = !matches;
    }

    if (resetBtn){
      resetBtn.addEventListener("click", openResetModal);
    }
    if (resetInput){
      resetInput.addEventListener("input", updateResetConfirmState);
      resetInput.addEventListener("keydown", event=>{
        if (event.key === "Enter" && resetConfirmBtn && !resetConfirmBtn.disabled){
          event.preventDefault();
          if (normalizeWord(resetInput.value) === normalizeWord(currentResetWord)){
            performReset();
            closeResetModal();
          }
        }
      });
    }
    if (resetConfirmBtn){
      resetConfirmBtn.addEventListener("click", ()=>{
        const inputValue = resetInput ? resetInput.value : "";
        if (normalizeWord(inputValue) === normalizeWord(currentResetWord)){
          performReset();
          closeResetModal();
        }
      });
    }
    if (resetCancelBtn){
      resetCancelBtn.addEventListener("click", closeResetModal);
    }
    if (resetCloseBtn){
      resetCloseBtn.addEventListener("click", closeResetModal);
    }
    if (resetModal){
      resetModal.addEventListener("click", event=>{
        if (event.target === resetModal) closeResetModal();
      });
    }

    document.addEventListener("keydown", event=>{
      if (event.key === "Escape"){
        if (resetModal && !resetModal.classList.contains("hidden")) closeResetModal();
      }
    });

    // Offline progress (avec bonus offline via Actinides)
    (function applyOfflineProgress(){
      if (!last) return;
      const elapsedMs = Math.max(0, Date.now() - last);
      const elapsed = Math.floor(elapsedMs / 1000);
      if (elapsed <= 0) return;
      const { APS, offlineBonus } = computeDerivedStats();
      if (APS > 0){
        const apsInt = toNonNegativeInt(APS);
        const bonus = Math.max(0, Math.min(offlineBonus, MULTIPLIER_SCALE));
        const scaledElapsed = ValueMath.mul(apsInt, elapsed);
        const gain = ValueMath.divScale(scaledElapsed, ValueMath.add(MULTIPLIER_SCALE, bonus), MULTIPLIER_SCALE);
        addAtoms(gain, { silent:true });
      }
    })();

    // Boucle d’auto-gain
    setInterval(()=>{
      const { APS } = computeDerivedStats();
      addAtoms(toNonNegativeInt(APS), { silent:true });
    }, 1000);

    setInterval(()=> handleAutoGachaTick(1), 1000);

    // Apparition du bonus Frénésie
    setInterval(()=>{
      checkApcFrenzySpawn();
      checkApsFrenzySpawn();
    }, 1000);

    // Rendu + autosave
    setInterval(()=>{ saveAll(); updateUI(); }, 1000);

    function updateReviveNavState(){
      if (reviveNavButton){
        reviveNavButton.disabled = !reviveUnlocked;
      }
    }

    function updateReviveUI(){
      const baseBonus = getReviveTotalBonus(reviveCount);
      if (reviveCountStatEl) reviveCountStatEl.textContent = formatNumber(reviveCount);
      if (reviveBaseStatEl){
        const bonusText = reviveCount > 0 ? `+${formatNumber(baseBonus)}` : "+0";
        reviveBaseStatEl.textContent = bonusText;
      }
      const shopIncrement = getReviveShopIncrementValue();
      if (reviveShopStatEl) reviveShopStatEl.textContent = `+${formatNumber(shopIncrement)} / achat`;
      const accessible = reviveUnlocked;
      if (reviveOfferEl) reviveOfferEl.classList.toggle("hidden", !accessible);
      if (reviveLockedMessageEl){
        if (!accessible){
          const unlockCostText = formatNumber(getReviveCostValue(0));
          reviveLockedMessageEl.textContent = `Atteins ${unlockCostText} Atoms simultanément pour débloquer la renaissance.`;
          reviveLockedMessageEl.classList.remove("hidden");
        } else {
          reviveLockedMessageEl.classList.add("hidden");
        }
      }
      if (!reviveBuyBtn) return;
      const tier = getReviveTier(reviveCount);
      const hasTier = accessible && tier && Number.isFinite(tier.cost) && tier.cost > 0 && tier.cost < Number.MAX_VALUE;
      if (reviveCostValueEl){
        if (hasTier){
          reviveCostValueEl.textContent = `${formatNumber(tier.cost)} Atoms`;
        } else {
          reviveCostValueEl.textContent = "—";
        }
      }
      if (reviveRewardValueEl){
        if (hasTier){
          reviveRewardValueEl.textContent = `+${formatNumber(tier.reward)} APC / APS`;
        } else if (!accessible){
          reviveRewardValueEl.textContent = "+0 APC / APS";
        } else {
          reviveRewardValueEl.textContent = "Bonus maximal atteint";
        }
      }
      if (!accessible){
        reviveBuyBtn.disabled = true;
        return;
      }
      if (!hasTier){
        reviveBuyBtn.disabled = true;
        reviveBuyBtn.textContent = "Renaissance maximale";
        return;
      }
      const costText = formatNumber(tier.cost);
      const canAfford = atoms >= tier.cost;
      reviveBuyBtn.disabled = !canAfford;
      reviveBuyBtn.textContent = canAfford ? `Déclencher (${costText})` : `Coût : ${costText}`;
    }

    function updateUI(){
      const derived = computeDerivedStats();
      const { APC, APS, isoDiscount = 0, inflRed = 0, apcFrenzyMultiplier = 1, apsFrenzyMultiplier = 1, frenzyBase = currentFrenzyMultiplierBase } = derived;
      currentIsoDiscount = isoDiscount;
      currentRollDiscount = clampRollDiscount(inflRed);
      updateAutoGachaHeader();
      updateReviveNavState();

      const atomsText = formatNumber(atoms);
      const apsText = formatNumber(APS);
      const apcText = formatNumber(APC);

      if (elAtoms) elAtoms.textContent = atomsText;
      elAps.textContent = apsText;
      elApc.textContent = apcText;

      elAtomsShop.textContent = atomsText;
      elApsShop.textContent = apsText;
      elApcShop.textContent = apcText;

      if (elAtomsGacha) elAtomsGacha.textContent = atomsText;
      if (elApsGacha) elApsGacha.textContent = apsText;
      if (elApcGacha) elApcGacha.textContent = apcText;

      if (apcFrenzyStatusEl){
        const stacks = getApcFrenzyStackCount();
        if (stacks > 0){
          const remainingMs = getLongestApcFrenzyRemaining();
          const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));
          apcFrenzyStatusEl.textContent = `×${formatNumber(apcFrenzyMultiplier)} – ${remainingSec}s`;
          apcFrenzyStatusEl.classList.add("active");
        } else {
          apcFrenzyStatusEl.textContent = "";
          apcFrenzyStatusEl.classList.remove("active");
        }
      }

      if (apsFrenzyStatusEl){
        const stacks = getApsFrenzyStackCount();
        if (stacks > 0){
          const remainingMs = getLongestApsFrenzyRemaining();
          const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));
          apsFrenzyStatusEl.textContent = `×${formatNumber(apsFrenzyMultiplier)} – ${remainingSec}s`;
          apsFrenzyStatusEl.classList.add("active");
        } else {
          apsFrenzyStatusEl.textContent = "";
          apsFrenzyStatusEl.classList.remove("active");
        }
      }

      const now = Date.now();
      if (infosSessionAtomsEl){
        infosSessionAtomsEl.textContent = formatNumber(sessionAtomsGained);
      }
      if (infosSessionClicksEl) infosSessionClicksEl.textContent = formatNumber(sessionManualClicks);
      if (infosSessionDurationEl) infosSessionDurationEl.textContent = formatSessionDuration(now - sessionStartTime);
      if (infosReviveAtomsEl) infosReviveAtomsEl.textContent = formatNumber(reviveRunAtoms);
      if (infosLifetimeAtomsEl) infosLifetimeAtomsEl.textContent = formatNumber(totalAtoms);
      if (infosReviveClicksEl) infosReviveClicksEl.textContent = formatNumber(reviveRunClicks);
      if (infosLifetimeClicksEl) infosLifetimeClicksEl.textContent = formatNumber(manualClicksTotal);
      if (infosReviveCountEl) infosReviveCountEl.textContent = formatNumber(reviveCount);
      if (infosTotalRuntimeEl) infosTotalRuntimeEl.textContent = formatRuntimeDuration(Math.max(0, now - gameStart));

      if (infosApcBaseEl) infosApcBaseEl.textContent = formatNumber(derived.apcBaseValue);
      if (infosApcFlatEl) infosApcFlatEl.textContent = formatNumber(derived.apcFlat);
      if (infosApcAfterFlatEl) infosApcAfterFlatEl.textContent = formatNumber(derived.apcAfterFlat);
      if (infosApcTotalEl) infosApcTotalEl.textContent = apcText;
      renderMultiplierList(infosApcMultipliersEl, [
        { label: 'Bonus APC', value: derived.apcFamilyMultiplier },
        { label: 'Bonus métalloïdes', value: derived.apcHybridMultiplier },
        { label: 'Multiplicateur global', value: derived.apcGlobalMultiplier },
        { label: 'Frénésie APC', value: derived.apcFrenzyMultiplier },
        { label: 'Multiplicateur APC (boutique)', value: derived.apcShopMultiplier }
      ]);

      if (infosApsBaseEl) infosApsBaseEl.textContent = formatNumber(derived.apsBaseValue);
      if (infosApsFlatEl) infosApsFlatEl.textContent = formatNumber(derived.apsFlat);
      if (infosApsAfterFlatEl) infosApsAfterFlatEl.textContent = formatNumber(derived.apsAfterFlat);
      if (infosApsTotalEl) infosApsTotalEl.textContent = apsText;
      renderMultiplierList(infosApsMultipliersEl, [
        { label: 'Bonus APS', value: derived.apsFamilyMultiplier },
        { label: 'Bonus métalloïdes', value: derived.apsHybridMultiplier },
        { label: 'Multiplicateur global', value: derived.apsGlobalMultiplier },
        { label: 'Frénésie APS', value: derived.apsFrenzyMultiplier },
        { label: 'Multiplicateur APS (boutique)', value: derived.apsShopMultiplier }
      ]);

      // Boutons de base
      const shopIncrement = getReviveShopIncrementValue();
      const shopIncrementText = formatNumber(shopIncrement);
      const apcSingleCost = apcCost(apcLvl);
      const autoSingleCost = autoCost(autoLvl);
      const apcBulk10Cost = computeBulkUpgradeCost(apcCost, apcLvl, 10);
      const apcBulk100Cost = computeBulkUpgradeCost(apcCost, apcLvl, 100);
      const autoBulk10Cost = computeBulkUpgradeCost(autoCost, autoLvl, 10);
      const autoBulk100Cost = computeBulkUpgradeCost(autoCost, autoLvl, 100);
      const apcMultiCost = computeMultiplierCost(apcMultiLvl);
      const apsMultiCost = computeMultiplierCost(apsMultiLvl);

      const apcInc10 = shopIncrement * 10;
      const apcInc100 = shopIncrement * 100;
      const autoInc10 = shopIncrement * 10;
      const autoInc100 = shopIncrement * 100;

      const formatAtomsCost = value => `${formatNumber(value)} Atoms`;
      const applyShopState = (button, cost, label) => {
        if (!button) return;
        const priceEl = button.querySelector('.option-price');
        if (priceEl) priceEl.textContent = formatAtomsCost(cost);
        if (label) button.setAttribute('aria-label', label);
        const unavailable = atoms < cost;
        button.classList.toggle('not-available', unavailable);
        if (unavailable) {
          button.setAttribute('aria-disabled', 'true');
        } else {
          button.removeAttribute('aria-disabled');
        }
      };

      applyShopState(btnBuyApc, apcSingleCost, `Acheter APC ×1 (+${shopIncrementText}) pour ${formatAtomsCost(apcSingleCost)}`);
      applyShopState(btnBuyApc10, apcBulk10Cost, `Acheter APC ×10 (+${formatNumber(apcInc10)}) pour ${formatAtomsCost(apcBulk10Cost)}`);
      applyShopState(btnBuyApc100, apcBulk100Cost, `Acheter APC ×100 (+${formatNumber(apcInc100)}) pour ${formatAtomsCost(apcBulk100Cost)}`);
      if (infoApc) infoApc.textContent = `Niveau ${apcLvl} – +${shopIncrementText} APC / achat`;

      applyShopState(btnBuyAuto, autoSingleCost, `Acheter Auto ×1 (+${shopIncrementText} APS) pour ${formatAtomsCost(autoSingleCost)}`);
      applyShopState(btnBuyAuto10, autoBulk10Cost, `Acheter Auto ×10 (+${formatNumber(autoInc10)} APS) pour ${formatAtomsCost(autoBulk10Cost)}`);
      applyShopState(btnBuyAuto100, autoBulk100Cost, `Acheter Auto ×100 (+${formatNumber(autoInc100)} APS) pour ${formatAtomsCost(autoBulk100Cost)}`);
      if (infoAuto) infoAuto.textContent = `Niveau ${autoLvl} – +${shopIncrementText} APS / achat`;

      const apcMultiTotal = getShopMultiplier(apcMultiLvl);
      const apcNextMultiplier = getShopMultiplier(apcMultiLvl + 1);
      applyShopState(btnBuyApcMulti, apcMultiCost, `Acheter multiplicateur APC (→ ×${formatNumber(apcNextMultiplier)}) pour ${formatAtomsCost(apcMultiCost)}`);
      if (btnBuyApcMulti){
        const tierEl = btnBuyApcMulti.querySelector('.option-tier');
        if (tierEl) tierEl.textContent = `×${formatNumber(apcNextMultiplier)}`;
      }
      if (infoApcMulti) infoApcMulti.textContent = `Achats ${apcMultiLvl} (×${formatNumber(apcMultiTotal)})`;

      const apsMultiTotal = getShopMultiplier(apsMultiLvl);
      const apsNextMultiplier = getShopMultiplier(apsMultiLvl + 1);
      applyShopState(btnBuyApsMulti, apsMultiCost, `Acheter multiplicateur APS (→ ×${formatNumber(apsNextMultiplier)}) pour ${formatAtomsCost(apsMultiCost)}`);
      if (btnBuyApsMulti){
        const tierEl = btnBuyApsMulti.querySelector('.option-tier');
        if (tierEl) tierEl.textContent = `×${formatNumber(apsNextMultiplier)}`;
      }
      if (infoApsMulti) infoApsMulti.textContent = `Achats ${apsMultiLvl} (×${formatNumber(apsMultiTotal)})`;

      // Gacha infos
      const displayedRollCost = getDiscountedRollCost(gacha.rollCost, currentRollDiscount);
      applyShopState(rollBtn, displayedRollCost, `Tirage gacha ×1 pour ${formatAtomsCost(displayedRollCost)}`);
      if (rollCostOnBtn) rollCostOnBtn.textContent = formatAtomsCost(displayedRollCost);
      if (roll10CostOnBtn){
        const bulk10Cost = computeBulkRollCost(10, { baseCost: gacha.rollCost, discount: currentRollDiscount });
        applyShopState(roll10Btn, bulk10Cost, `Tirage gacha ×10 pour ${formatAtomsCost(bulk10Cost)}`);
        roll10CostOnBtn.textContent = formatAtomsCost(bulk10Cost);
      }
      if (roll100CostOnBtn){
        const bulk100Cost = computeBulkRollCost(100, { baseCost: gacha.rollCost, discount: currentRollDiscount });
        applyShopState(roll100Btn, bulk100Cost, `Tirage gacha ×100 pour ${formatAtomsCost(bulk100Cost)}`);
        roll100CostOnBtn.textContent = formatAtomsCost(bulk100Cost);
      }
      if (isotopesEl) isotopesEl.textContent = formatNumber(gacha.isotopes);

      refreshMoleculeUI();
      refreshBonusList();
      refreshAwakenHighlights();
      updateReviveUI();
      refreshElementPanel();
      updateAutoGachaPanel();
    }

    /* ===================== DevKit ===================== */
    (function setupDevKit(){
      const DEVKIT_VERSION = "1.0.0";

      function toSafeInt(value){
        const numeric = Math.floor(Number(value));
        return Number.isFinite(numeric) ? numeric : 0;
      }

      function ensureReviveState(target, options = {}){
        const count = Math.max(0, toSafeInt(target));
        reviveCount = count;
        if (options.forceLock){
          reviveUnlocked = false;
        } else if (count > 0 || options.unlock === true){
          reviveUnlocked = true;
        }
        if (options.adjustBase !== false){
          const baseValues = getReviveBaseStartValue(count);
          if (baseValues){
            if (Number.isFinite(baseValues.apc)) baseApc = Math.max(baseApc, baseValues.apc);
            if (Number.isFinite(baseValues.aps)) baseAps = Math.max(baseAps, baseValues.aps);
          }
        }
        updateReviveNavState();
        return count;
      }

      function countUnlockedMolecules(){
        const state = getMoleculeState();
        if (!state.unlocked || typeof state.unlocked !== "object") return 0;
        return Object.keys(state.unlocked).filter(key => state.unlocked[key]).length;
      }

      const devKitApi = {
        getSnapshot(){
          const derived = computeDerivedStats();
          syncTotalIsotopes();
          return {
            atoms,
            baseApc,
            baseAps,
            APC: derived.APC,
            APS: derived.APS,
            apcFlatBonus: derived.apcFlat,
            apsFlatBonus: derived.apsFlat,
            reviveCount,
            reviveUnlocked,
            reviveNextCost: getReviveCostValue(reviveCount),
            reviveNextReward: getReviveRewardValue(reviveCount),
            ownedElements: getOwnedElementCount(),
            totalElements: ORDERED_SYMBOLS.length,
            awakenCount: getTotalAwakenCount(),
            rollCost: gacha.rollCost,
            isotopes: gacha.isotopes,
            moleculeDust: getMoleculeDust(),
            moleculesUnlocked: countUnlockedMolecules(),
            moleculesTotal: Object.keys(MOLECULE_BY_KEY).length
          };
        },
        giveAtoms(amount, options = {}){
          const inc = toSafeInt(amount);
          if (!inc) return false;
          if (inc > 0){
            const success = addAtoms(inc, { silent: options.silent === true });
            if (success) saveAndUpdate();
            return success;
          }
          const next = Math.max(0, atoms + inc);
          if (next === atoms) return false;
          atoms = next;
          saveAndUpdate();
          return true;
        },
        boostBaseApc(amount){
          const inc = toSafeInt(amount);
          if (!inc) return false;
          const next = baseApc + inc;
          if (!Number.isFinite(next)) return false;
          baseApc = Math.max(0, next);
          saveAndUpdate();
          return true;
        },
        boostBaseAps(amount){
          const inc = toSafeInt(amount);
          if (!inc) return false;
          const next = baseAps + inc;
          if (!Number.isFinite(next)) return false;
          baseAps = Math.max(0, next);
          saveAndUpdate();
          return true;
        },
        setReviveCount(value, options = {}){
          ensureReviveState(value, options);
          if (options.resetRunStats){
            reviveRunAtoms = 0;
            reviveRunClicks = 0;
          }
          saveAndUpdate();
          return true;
        },
        addRevives(amount, options = {}){
          const inc = Math.max(0, toSafeInt(amount));
          if (!inc) return false;
          const target = reviveCount + inc;
          ensureReviveState(target, options);
          saveAndUpdate();
          return true;
        },
        unlockAllElements(){
          if (!gacha.owned || typeof gacha.owned !== "object") gacha.owned = {};
          let changed = false;
          for (const symbol of ORDERED_SYMBOLS){
            if (!gacha.owned[symbol]){
              gacha.owned[symbol] = 1;
              changed = true;
            }
          }
          if (!changed) return false;
          buildPeriodicGrids();
          saveAndUpdate();
          return true;
        },
        giveIsotopesAll(amount, { includeUnowned = false } = {}){
          const inc = Math.max(0, toSafeInt(amount));
          if (!inc) return false;
          let changed = false;
          for (const symbol of ORDERED_SYMBOLS){
            if (!includeUnowned && !gacha.owned[symbol]) continue;
            addIsotopes(symbol, inc);
            changed = true;
          }
          if (changed) saveAndUpdate();
          return changed;
        },
        forceAwakenAll(){
          let changed = false;
          let totalLevels = 0;
          for (const symbol of ORDERED_SYMBOLS){
            if (!gacha.owned[symbol]) continue;
            const current = getAwakenLevel(symbol);
            if (current < AWAKEN_MAX){
              setAwakenLevel(symbol, AWAKEN_MAX);
              changed = true;
            }
            totalLevels += getAwakenLevel(symbol);
          }
          const previous = getTotalAwakenCount();
          const newTotal = Math.max(previous, totalLevels);
          gacha.awakenCount = newTotal;
          if (changed || newTotal !== previous){
            saveAndUpdate();
            return true;
          }
          return false;
        },
        resetRollCost(value = INITIAL_ROLL_COST){
          const numeric = toSafeInt(value);
          const cost = Number.isFinite(numeric) && numeric > 0 ? numeric : INITIAL_ROLL_COST;
          gacha.rollCost = Math.max(1, cost);
          saveAndUpdate();
          return true;
        },
        unlockAllMolecules(){
          const state = getMoleculeState();
          if (!state.unlocked || typeof state.unlocked !== "object") state.unlocked = {};
          let changed = false;
          for (const key of Object.keys(MOLECULE_BY_KEY)){
            if (!state.unlocked[key]){
              state.unlocked[key] = true;
              changed = true;
            }
          }
          if (!changed) return false;
          saveAndUpdate();
          return true;
        },
        giveMoleculeDust(amount){
          const inc = Math.max(0, toSafeInt(amount));
          if (!inc) return false;
          addMoleculeDust(inc);
          saveAndUpdate();
          return true;
        }
      };

      const bridge = (typeof window !== "undefined" && window.AtomesDevKit && typeof window.AtomesDevKit === "object")
        ? window.AtomesDevKit
        : {};
      bridge.version = DEVKIT_VERSION;
      bridge.api = devKitApi;
      bridge.ValueMath = ValueMath;
      bridge.withAPI = function(callback){
        if (typeof callback === "function"){
          try {
            callback(devKitApi);
          } catch (error){
            console.error("[DevKit] callback error", error);
          }
        }
      };
      window.AtomesDevKit = bridge;
      try {
        window.dispatchEvent(new CustomEvent("atoms-devkit-ready", { detail: devKitApi }));
      } catch (error){
        console.error("[DevKit] unable to dispatch readiness event", error);
      }
    })();

    // Init
    checkTrophies({ silent:true });
    resetAutoGachaCooldown();
    updateAutoGachaHeader();
    updateAutoGachaPanel();
    buildPeriodicGrids();
    updateReviveNavState();
    updateReviveUI();
    activatePage("mainPage");
  </script>
  <!-- Retirer la ligne suivante pour désactiver la DevKit -->
  <script src="Assets/devkit/devkit.js"></script>
</body>
</html>
